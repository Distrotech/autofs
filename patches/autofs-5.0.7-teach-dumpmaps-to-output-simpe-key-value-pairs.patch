Bottom: b10774af614d756988a15191dee45e98d24552c1
Top:    224627f24060149c51b335515fa27c75ab52c1df
Author: Ian Kent <raven@themaw.net>
Date:   2013-07-31 14:54:39 +0800

autofs-5.0.7 - teach dumpmaps to output simpe key value pairs


---

diff --git a/daemon/automount.c b/daemon/automount.c
index 6849272..c52eedc 100644
--- a/daemon/automount.c
+++ b/daemon/automount.c
@@ -2125,21 +2125,23 @@ int main(int argc, char *argv[])
 			program);
 #endif
 
-	if (argc == 0)
-		master_list = master_new(NULL, timeout, ghost);
-	else
-		master_list = master_new(argv[0], timeout, ghost);
-
-	if (!master_list) {
-		printf("%s: can't create master map %s", program, argv[0]);
-		exit(1);
-	}
-
 	if (dumpmaps) {
 		struct master_mapent *entry;
 		struct list_head *head, *p;
 		struct mapent_cache *nc;
 
+		/*
+		 * We can't specify a master map on the command line
+		 * when listing one or more maps for display so the
+		 * only way to alter it from the ddefault name is to
+		 * set ti in the configuration.
+		 */
+		master_list = master_new(NULL, timeout, ghost);
+		if (!master_list) {
+			printf("%s: can't create master map", program);
+			exit(1);
+		}
+
 		open_log();
 
 		master_init_scan();
@@ -2168,6 +2170,16 @@ int main(int argc, char *argv[])
 		exit(0);
 	}
 
+	if (argc == 0)
+		master_list = master_new(NULL, timeout, ghost);
+	else
+		master_list = master_new(argv[0], timeout, ghost);
+
+	if (!master_list) {
+		printf("%s: can't create master map %s", program, argv[0]);
+		exit(1);
+	}
+
 	become_daemon(foreground, daemon_check);
 
 	if (pthread_attr_init(&th_attr)) {
diff --git a/lib/master.c b/lib/master.c
index c560496..b34e906 100644
--- a/lib/master.c
+++ b/lib/master.c
@@ -1329,6 +1329,128 @@ static void print_map_info(struct map_source *source)
 	return;
 }
 
+static char *match_map_name(const char *match, const char *maps)
+{
+}
+
+static int compare_source_type(struct map_source *map, const char *type)
+{
+	int res = 0;
+
+	if (type) {
+		if (!map->type)
+			goto done;
+
+		if (strcmp(map->type, type))
+			goto done;
+	} else if (map->type)
+		goto done;
+
+	res = 1;
+done:
+	return res;
+}
+
+int dump_map(struct master *master, const char *type, const char *names)
+{
+	struct list_head *p, *head;
+
+	if (list_empty(&master->mounts)) {
+		printf("no master map entries found\n\n");
+		return 1;
+	}
+
+	head = &master->mounts;
+	p = head->next;
+	while (p != head) {
+		struct map_source *source;
+		struct master_mapent *this;
+		struct autofs_point *ap;
+		time_t now = time(NULL);
+		unsigned int count = 0;
+		int i;
+
+		this = list_entry(p, struct master_mapent, list);
+		p = p->next;
+
+		ap = this->ap;
+
+		/*
+		 * Ensure we actually read indirect map entries so we can
+		 * list them. The map reads won't read any indirect map
+		 * entries (other than those in a file map) unless the
+		 * browse option is set.
+		 */
+		if (ap->type == LKP_INDIRECT)
+			ap->flags |= MOUNT_FLAG_GHOST;
+
+		/* Read the map content into the cache */
+		if (lookup_nss_read_map(ap, NULL, now))
+			lookup_prune_cache(ap, now);
+		else {
+			printf("  failed to read map\n\n");
+			continue;
+		}
+
+		if (!this->maps) {
+			printf("  no map sources found\n\n");
+			continue;
+		}
+
+		source = this->maps;
+		while (source) {
+			struct map_source *instance;
+			struct mapent *me;
+
+			instance = NULL;
+			if (source->type) {
+				if ((!strcmp(type, "file") &&
+				     strcmp(source->type, "files")) ||
+				     strcmp(source->type, type)) {
+					source = source->next;
+					continue;
+				}
+				instance = source;
+			} else {
+				struct map_source *map;
+				int res;
+
+				map = source->instance;
+				while (map) {
+					res = compare_source_type(map, type);
+					if (res) {
+						instance = map;
+						break;
+					}
+					map = map->next;
+				}
+				if (!instance) {
+					source = source->next;
+					continue;
+				}
+			}
+
+			me = cache_lookup_first(source->mc);
+			if (!me)
+				printf("  no keys found in map\n");
+			else {
+				do {
+					if (me->source == instance)
+						printf("%s\t%s\n", me->key, me->mapent);
+				} while ((me = cache_lookup_next(source->mc, me)));
+			}
+
+			source = source->next;
+		}
+
+		lookup_close_lookup(ap);
+	}
+
+	return 1;
+}
+
+}
+
 int master_show_mounts(struct master *master)
 {
 	struct list_head *p, *head;
