Bottom: ff8c8cd69d7c8182f3be6b4bd874f5c7c33c60de
Top:    f256cf4caf47041dcde69ed0cc72dc99def26723
Author: Ian Kent <raven@themaw.net>
Date:   2013-07-31 18:03:43 +0800

debug.patch


---

diff --git a/daemon/automount.c b/daemon/automount.c
index 2008905..20db8af 100644
--- a/daemon/automount.c
+++ b/daemon/automount.c
@@ -2142,6 +2142,8 @@ int main(int argc, char *argv[])
 				master = argv[2];
 		}
 
+		printf("type %s name %s master %s\n", type, name, master);
+
 		if (master)
 			master_list = master_new(NULL, timeout, ghost);
 		else
@@ -2151,7 +2153,7 @@ int main(int argc, char *argv[])
 			exit(1);
 		}
 
-		open_log();
+		log_to_stderr();
 
 		master_init_scan();
 
@@ -2164,9 +2166,10 @@ int main(int argc, char *argv[])
 		master_list->nc = nc;
 
 		lookup_nss_read_master(master_list, 0);
-		if (type)
+		if (type) {
+			printf("call dump_map");
 			dump_map(master_list, type, name);
-		else
+		} else
 			master_show_mounts(master_list);
 
 		head = &master_list->mounts;
diff --git a/lib/master.c b/lib/master.c
index abc7306..adadec2 100644
--- a/lib/master.c
+++ b/lib/master.c
@@ -1399,6 +1399,8 @@ int dump_map(struct master *master, const char *type, const char *name)
 
 		ap = this->ap;
 
+		printf("ap->path %s\n", ap->path);
+
 		/*
 		 * Ensure we actually read indirect map entries so we can
 		 * list them. The map reads won't read any indirect map
@@ -1430,6 +1432,7 @@ int dump_map(struct master *master, const char *type, const char *name)
 
 			instance = NULL;
 			if (source->type) {
+				printf("source->type %s\n", source->type);
 				if ((!strcmp(type, "file") &&
 				     strcmp(source->type, "files")) ||
 				     strcmp(source->type, type)) {
@@ -1449,6 +1452,7 @@ int dump_map(struct master *master, const char *type, const char *name)
 
 				map = source->instance;
 				while (map) {
+					printf("map->type %s\n", map->type);
 					res = compare_source_type(map, type);
 					if (res) {
 						if (!match_map_name(map, name)) {
@@ -1462,6 +1466,8 @@ int dump_map(struct master *master, const char *type, const char *name)
 				}
 			}
 
+			printf("instance %p\n", instance);
+
 			if (!instance) {
 				source = source->next;
 				lookup_close_lookup(ap);
