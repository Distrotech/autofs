diff -Nur linux-2.4.20.dist/fs/autofs4/autofs_i.h autofs4-2.4/fs/autofs4/autofs_i.h
--- linux-2.4.20.dist/fs/autofs4/autofs_i.h	2002-08-03 08:39:45.000000000 +0800
+++ autofs4-2.4/fs/autofs4/autofs_i.h	2003-11-09 19:33:53.000000000 +0800
@@ -56,6 +56,9 @@
 
 	int		flags;
 
+	atomic_t	fp_count;
+	struct file	*fp;
+
 	struct autofs_sb_info *sbi;
 	unsigned long last_used;
 
@@ -73,6 +76,7 @@
 struct autofs_wait_queue {
 	wait_queue_head_t queue;
 	struct autofs_wait_queue *next;
+	struct task_struct *owner;
 	autofs_wqt_t wait_queue_token;
 	/* We use the following to see what we are waiting for */
 	int hash;
@@ -91,7 +95,10 @@
 	pid_t oz_pgrp;
 	int catatonic;
 	int version;
+	int sub_version;
 	unsigned long exp_timeout;
+	int reghost_enabled;
+	int needs_reghost;
 	struct super_block *sb;
 	struct autofs_wait_queue *queues; /* Wait queue pointer */
 };
@@ -123,6 +130,12 @@
 		(inf != NULL && inf->flags & AUTOFS_INF_EXPIRING);
 }
 
+static inline void autofs4_copy_atime(struct file *src, struct file *dst)
+{
+	dst->f_dentry->d_inode->i_atime = src->f_dentry->d_inode->i_atime;
+	return;
+}
+
 struct inode *autofs4_get_inode(struct super_block *, struct autofs_info *);
 struct autofs_info *autofs4_init_inf(struct autofs_sb_info *, mode_t mode);
 void autofs4_free_ino(struct autofs_info *);
@@ -139,6 +152,7 @@
 extern struct inode_operations autofs4_symlink_inode_operations;
 extern struct inode_operations autofs4_dir_inode_operations;
 extern struct inode_operations autofs4_root_inode_operations;
+extern struct file_operations autofs4_dir_operations;
 extern struct file_operations autofs4_root_operations;
 
 /* Initializing function */
@@ -155,6 +169,56 @@
 	NFY_EXPIRE
 };
 
-int autofs4_wait(struct autofs_sb_info *,struct qstr *, enum autofs_notify);
+int autofs4_wait(struct autofs_sb_info *,struct dentry *, enum autofs_notify);
 int autofs4_wait_release(struct autofs_sb_info *,autofs_wqt_t,int);
 void autofs4_catatonic_mode(struct autofs_sb_info *);
+
+#if !defined(REDHAT_KERNEL) || LINUX_VERSION_CODE < KERNEL_VERSION(2,4,19)
+/**
+ * list_for_each_entry  -       iterate over list of given type
+ * @pos:        the type * to use as a loop counter.
+ * @head:       the head for your list.
+ * @member:     the name of the list_struct within the struct.
+ */
+#define list_for_each_entry(pos, head, member)                          \
+        for (pos = list_entry((head)->next, typeof(*pos), member),      \
+                     prefetch(pos->member.next);                        \
+             &pos->member != (head);                                    \
+             pos = list_entry(pos->member.next, typeof(*pos), member),  \
+                     prefetch(pos->member.next))
+
+#endif
+
+static inline int simple_positive(struct dentry *dentry)
+{
+	return dentry->d_inode && !d_unhashed(dentry);
+}
+
+static inline int simple_empty_nolock(struct dentry *dentry)
+{
+	struct dentry *child;
+	int ret = 0;
+
+	list_for_each_entry(child, &dentry->d_subdirs, d_child)
+		if (simple_positive(child))
+			goto out;
+	ret = 1;
+out:
+	return ret;
+}
+
+static inline int simple_empty(struct dentry *dentry)
+{
+	struct dentry *child;
+	int ret = 0;
+
+	spin_lock(&dcache_lock);
+	list_for_each_entry(child, &dentry->d_subdirs, d_child)
+		if (simple_positive(child))
+			goto out;
+	ret = 1;
+out:
+	spin_unlock(&dcache_lock);
+	return ret;
+}
+
diff -Nur linux-2.4.20.dist/fs/autofs4/expire.c autofs4-2.4/fs/autofs4/expire.c
--- linux-2.4.20.dist/fs/autofs4/expire.c	2001-06-12 10:15:27.000000000 +0800
+++ autofs4-2.4/fs/autofs4/expire.c	2003-11-09 19:33:53.000000000 +0800
@@ -4,6 +4,7 @@
  *
  *  Copyright 1997-1998 Transmeta Corporation -- All Rights Reserved
  *  Copyright 1999-2000 Jeremy Fitzhardinge <jeremy@goop.org>
+ *  Copyright 2001-2003 Ian Kent <raven@themaw.net>
  *
  * This file is part of the Linux kernel and is made available under
  * the terms of the GNU General Public License, version 2, or at your
@@ -13,134 +14,238 @@
 
 #include "autofs_i.h"
 
-/*
- * Determine if a subtree of the namespace is busy.
- *
- * mnt is the mount tree under the autofs mountpoint
- */
-static inline int is_vfsmnt_tree_busy(struct vfsmount *mnt)
+static unsigned long now;
+
+/* Check if a dentry can be expired return 1 if it can else return 0 */
+static inline int autofs4_can_expire(struct dentry *dentry,
+					unsigned long timeout, int do_now)
+{
+	struct autofs_info *ino = autofs4_dentry_ino(dentry);
+
+	/* dentry in the process of being deleted */
+	if (ino == NULL)
+		return 0;
+
+	/* No point expiring a pending mount */
+	if (dentry->d_flags & DCACHE_AUTOFS_PENDING)
+		return 0;
+
+	if (!do_now) {
+		/* Too young to die */
+		if (time_after(ino->last_used + timeout, now))
+			return 0;
+		
+		/* update last_used here :- 
+		   - obviously makes sense if it is in use now
+		   - less obviously, prevents rapid-fire expire
+		     attempts if expire fails the first time */
+		ino->last_used = now;
+	}
+
+	return 1;
+}
+
+/* Sorry I can't solve the problem without using counts either */
+static int autofs4_may_umount(struct vfsmount *mnt)
 {
-	struct vfsmount *this_parent = mnt;
 	struct list_head *next;
-	int count;
+	struct vfsmount *this_parent = mnt;
+	int actual_refs;
+	int minimum_refs;
 
-	count = atomic_read(&mnt->mnt_count) - 1;
+	actual_refs = atomic_read(&mnt->mnt_count);
+	minimum_refs = 2;
 
+	spin_lock(&dcache_lock);
 repeat:
 	next = this_parent->mnt_mounts.next;
-	DPRINTK(("is_vfsmnt_tree_busy: mnt=%p, this_parent=%p, next=%p\n",
-		 mnt, this_parent, next));
 resume:
-	for( ; next != &this_parent->mnt_mounts; next = next->next) {
-		struct vfsmount *p = list_entry(next, struct vfsmount,
-						mnt_child);
-
-		/* -1 for struct vfs_mount's normal count, 
-		   -1 to compensate for child's reference to parent */
-		count += atomic_read(&p->mnt_count) - 1 - 1;
+	while (next != &this_parent->mnt_mounts) {
+		struct vfsmount *p = list_entry(next, struct vfsmount, mnt_child);
+
+		next = next->next;
 
-		DPRINTK(("is_vfsmnt_tree_busy: p=%p, count now %d\n",
-			 p, count));
+		actual_refs += atomic_read(&p->mnt_count);
+		minimum_refs += 2;
 
 		if (!list_empty(&p->mnt_mounts)) {
 			this_parent = p;
 			goto repeat;
 		}
-		/* root is busy if any leaf is busy */
-		if (atomic_read(&p->mnt_count) > 1)
-			return 1;
 	}
 
-	/* All done at this level ... ascend and resume the search. */
 	if (this_parent != mnt) {
-		next = this_parent->mnt_child.next; 
+		next = this_parent->mnt_child.next;
 		this_parent = this_parent->mnt_parent;
 		goto resume;
 	}
+	spin_unlock(&dcache_lock);
+
+	DPRINTK(("autofs4_may_umount: done actual = %d, minimum = %d\n",
+		 actual_refs, minimum_refs));
 
-	DPRINTK(("is_vfsmnt_tree_busy: count=%d\n", count));
-	return count != 0; /* remaining users? */
+	return actual_refs > minimum_refs;
 }
 
-/* Traverse a dentry's list of vfsmounts and return the number of
-   non-busy mounts */
-static int check_vfsmnt(struct vfsmount *mnt, struct dentry *dentry)
+/* Check a mount point for busyness return 1 if not busy, otherwise */
+static int autofs4_check_mount(struct vfsmount *mnt, struct dentry *dentry)
 {
-	int ret = dentry->d_mounted;
-	struct vfsmount *vfs = lookup_mnt(mnt, dentry);
+	int status = 0;
 
-	if (vfs && is_vfsmnt_tree_busy(vfs))
-		ret--;
-	DPRINTK(("check_vfsmnt: ret=%d\n", ret));
-	return ret;
+	DPRINTK(("autofs4_check_mount: dentry %p %.*s\n",
+		 dentry, (int)dentry->d_name.len, dentry->d_name.name));
+
+	mntget(mnt);
+	dget(dentry);
+
+	if (!follow_down(&mnt, &dentry))
+		goto done;
+
+	while (d_mountpoint(dentry) && follow_down(&mnt, &dentry))
+		;
+
+	/* This is an autofs submount, we can't expire it */
+	if (is_autofs4_dentry(dentry))
+		goto done;
+	
+	/* The big question */
+	if (autofs4_may_umount(mnt) == 0)
+		status = 1;
+done:
+	DPRINTK(("autofs4_check_mount: returning = %d\n", status));
+	mntput(mnt);
+	dput(dentry);
+	return status;
 }
 
-/* Check dentry tree for busyness.  If a dentry appears to be busy
-   because it is a mountpoint, check to see if the mounted
-   filesystem is busy. */
-static int is_tree_busy(struct vfsmount *topmnt, struct dentry *top)
+/* Check a directory tree of mount points for busyness
+ * The tree is not busy iff no mountpoints are busy 
+ * Return 1 if the tree is busy or 0 otherwise
+ */
+static int autofs4_check_tree(struct vfsmount *mnt,
+	       		      struct dentry *top,
+			      unsigned long timeout,
+			      int do_now)
 {
-	struct dentry *this_parent;
+	struct dentry *this_parent = top;
 	struct list_head *next;
-	int count;
 
-	count = atomic_read(&top->d_count);
-	
-	DPRINTK(("is_tree_busy: top=%p initial count=%d\n", 
-		 top, count));
-	this_parent = top;
-
-	if (is_autofs4_dentry(top)) {
-		count--;
-		DPRINTK(("is_tree_busy: autofs; count=%d\n", count));
-	}
+	DPRINTK(("autofs4_check_tree: parent %p %.*s\n",
+		 top, (int)top->d_name.len, top->d_name.name));
 
-	if (d_mountpoint(top))
-		count -= check_vfsmnt(topmnt, top);
+	/* Negative dentry - give up */
+	if (!simple_positive(top))
+		return 0;
+
+	/* Timeout of a tree mount is determined by its top dentry */
+	if (!autofs4_can_expire(top, timeout, do_now))
+		return 0;
 
- repeat:
+	spin_lock(&dcache_lock);
+repeat:
 	next = this_parent->d_subdirs.next;
- resume:
+resume:
 	while (next != &this_parent->d_subdirs) {
-		int adj = 0;
-		struct dentry *dentry = list_entry(next, struct dentry,
-						   d_child);
+		struct dentry *dentry = list_entry(next, struct dentry, d_child);
+
+		/* Negative dentry - give up */
+		if (!simple_positive(dentry)) {
+			next = next->next;
+			continue;
+		}
+
+		DPRINTK(("autofs4_check_tree: dentry %p %.*s\n",
+			 dentry, (int)dentry->d_name.len, dentry->d_name.name));
+
+		if (!list_empty(&dentry->d_subdirs)) {
+			this_parent = dentry;
+			goto repeat;
+		}
+
+		dentry = dget(dentry);
+		spin_unlock(&dcache_lock);
+
+		if (d_mountpoint(dentry)) {
+			/* First busy => tree busy */
+			if (!autofs4_check_mount(mnt, dentry)) {
+				dput(dentry);
+				return 0;
+			}
+		}
+
+		dput(dentry);
+		spin_lock(&dcache_lock);
 		next = next->next;
+	}
+
+	if (this_parent != top) {
+		next = this_parent->d_child.next;
+		this_parent = this_parent->d_parent;
+		goto resume;
+	}
+	spin_unlock(&dcache_lock);
+
+	return 1;
+}
+
+struct dentry *autofs4_check_leaves(struct vfsmount *mnt,
+				    struct dentry *parent,
+				    unsigned long timeout,
+				    int do_now)
+{
+	struct dentry *this_parent = parent;
+	struct list_head *next;
 
-		count += atomic_read(&dentry->d_count) - 1;
+	DPRINTK(("autofs4_check_leaves: parent %p %.*s\n",
+		 parent, (int)parent->d_name.len, parent->d_name.name));
 
-		if (d_mountpoint(dentry))
-			adj += check_vfsmnt(topmnt, dentry);
+	spin_lock(&dcache_lock);
+repeat:
+	next = this_parent->d_subdirs.next;
+resume:
+	while (next != &this_parent->d_subdirs) {
+		struct dentry *dentry = list_entry(next, struct dentry, d_child);
 
-		if (is_autofs4_dentry(dentry)) {
-			adj++;
-			DPRINTK(("is_tree_busy: autofs; adj=%d\n",
-				 adj));
+		/* Negative dentry - give up */
+		if (!simple_positive(dentry)) {
+			next = next->next;
+			continue;
 		}
 
-		count -= adj;
+		DPRINTK(("autofs4_check_leaves: dentry %p %.*s\n",
+			 dentry, (int)dentry->d_name.len, dentry->d_name.name));
 
 		if (!list_empty(&dentry->d_subdirs)) {
 			this_parent = dentry;
 			goto repeat;
 		}
 
-		if (atomic_read(&dentry->d_count) != adj) {
-			DPRINTK(("is_tree_busy: busy leaf (d_count=%d adj=%d)\n",
-				 atomic_read(&dentry->d_count), adj));
-			return 1;
+		dentry = dget(dentry);
+		spin_unlock(&dcache_lock);
+
+		if (d_mountpoint(dentry)) {
+			/* Can we expire this guy */
+			if (!autofs4_can_expire(dentry, timeout, do_now))
+				goto cont;
+
+			/* Can we umount this guy */
+			if (autofs4_check_mount(mnt, dentry))
+				return dentry;
 		}
+cont:
+		dput(dentry);
+		spin_lock(&dcache_lock);
+		next = next->next;
 	}
 
-	/* All done at this level ... ascend and resume the search. */
-	if (this_parent != top) {
-		next = this_parent->d_child.next; 
+	if (this_parent != parent) {
+		next = this_parent->d_child.next;
 		this_parent = this_parent->d_parent;
 		goto resume;
 	}
+	spin_unlock(&dcache_lock);
 
-	DPRINTK(("is_tree_busy: count=%d\n", count));
-	return count != 0; /* remaining users? */
+	return NULL;
 }
 
 /*
@@ -152,61 +257,86 @@
 static struct dentry *autofs4_expire(struct super_block *sb,
 				     struct vfsmount *mnt,
 				     struct autofs_sb_info *sbi,
-				     int do_now)
+				     int how)
 {
-	unsigned long now = jiffies;
 	unsigned long timeout;
 	struct dentry *root = sb->s_root;
-	struct list_head *tmp;
+	struct dentry *expired = NULL;
+	struct list_head *next;
+	int do_now = how & AUTOFS_EXP_IMMEDIATE;
+	int exp_leaves = how & AUTOFS_EXP_LEAVES;
 
 	if (!sbi->exp_timeout || !root)
 		return NULL;
 
+	now = jiffies;
 	timeout = sbi->exp_timeout;
 
 	spin_lock(&dcache_lock);
-	for(tmp = root->d_subdirs.next;
-	    tmp != &root->d_subdirs; 
-	    tmp = tmp->next) {
-		struct autofs_info *ino;
-		struct dentry *dentry = list_entry(tmp, struct dentry, d_child);
+	next = root->d_subdirs.next;
 
-		if (dentry->d_inode == NULL)
+	/* On exit from the loop expire is set to a dgot dentry
+	 * to expire or it's NULL */
+	while (next != &root->d_subdirs) {
+		struct dentry *dentry = list_entry(next, struct dentry, d_child);
+
+		/* Negative dentry - give up */
+		if (!simple_positive(dentry)) {
+			next = next->next;
 			continue;
+		}
 
-		ino = autofs4_dentry_ino(dentry);
+		dentry = dget(dentry);
+		spin_unlock(&dcache_lock);
 
-		if (ino == NULL) {
-			/* dentry in the process of being deleted */
-			continue;
+		/* Case 1: indirect mount or top level direct mount */
+		if (d_mountpoint(dentry)) {
+			DPRINTK(("autofs4_expire: checking mountpoint %p %.*s\n",
+			 dentry, (int)dentry->d_name.len, dentry->d_name.name));
+
+			/* Can we expire this guy */
+			if (!autofs4_can_expire(dentry, timeout, do_now))
+				goto next;
+
+			/* Can we umount this guy */
+			if (autofs4_check_mount(mnt, dentry)) {
+				expired = dentry;
+				break;
+			}
+			goto next;
 		}
 
-		/* No point expiring a pending mount */
-		if (dentry->d_flags & DCACHE_AUTOFS_PENDING)
-			continue;
+		if (simple_empty(dentry))
+			goto next;
 
-		if (!do_now) {
-			/* Too young to die */
-			if (time_after(ino->last_used + timeout, now))
-				continue;
-		
-			/* update last_used here :- 
-			   - obviously makes sense if it is in use now
-			   - less obviously, prevents rapid-fire expire
-			     attempts if expire fails the first time */
-			ino->last_used = now;
+		/* Case 2: tree mount, expire iff entire tree is not busy */
+		if (!exp_leaves) {
+			if (autofs4_check_tree(mnt, dentry, timeout, do_now)) {
+				expired = dentry;
+				break;
+			}
+		/* Case 3: direct mount, expire individual leaves */
+		} else {
+			expired = autofs4_check_leaves(mnt, dentry, timeout, do_now);
+			if (expired) {
+				dput(dentry);
+				break;
+			}
 		}
-		if (!is_tree_busy(mnt, dentry)) {
-			DPRINTK(("autofs_expire: returning %p %.*s\n",
-				 dentry, (int)dentry->d_name.len, dentry->d_name.name));
-			/* Start from here next time */
-			list_del(&root->d_subdirs);
-			list_add(&root->d_subdirs, &dentry->d_child);
-			dget(dentry);
-			spin_unlock(&dcache_lock);
+next:
+		dput(dentry);
+		spin_lock(&dcache_lock);
+		next = next->next;
+	}
 
-			return dentry;
-		}
+	if ( expired ) {
+		DPRINTK(("autofs4_expire: returning %p %.*s\n",
+			 expired, (int)expired->d_name.len, expired->d_name.name));
+		spin_lock(&dcache_lock);
+		list_del(&expired->d_parent->d_subdirs);
+		list_add(&expired->d_parent->d_subdirs, &expired->d_child);
+		spin_unlock(&dcache_lock);
+		return expired;
 	}
 	spin_unlock(&dcache_lock);
 
@@ -259,11 +389,11 @@
 		/* This is synchronous because it makes the daemon a
                    little easier */
 		de_info->flags |= AUTOFS_INF_EXPIRING;
-		ret = autofs4_wait(sbi, &dentry->d_name, NFY_EXPIRE);
+		ret = autofs4_wait(sbi, dentry, NFY_EXPIRE);
 		de_info->flags &= ~AUTOFS_INF_EXPIRING;
 		dput(dentry);
 	}
-		
+
 	return ret;
 }
 
diff -Nur linux-2.4.20.dist/fs/autofs4/inode.c autofs4-2.4/fs/autofs4/inode.c
--- linux-2.4.20.dist/fs/autofs4/inode.c	2002-08-03 08:39:45.000000000 +0800
+++ autofs4-2.4/fs/autofs4/inode.c	2003-11-09 19:33:53.000000000 +0800
@@ -45,6 +45,8 @@
 	ino->inode = NULL;
 	ino->dentry = NULL;
 	ino->size = 0;
+	atomic_set(&ino->fp_count, 0);
+	ino->fp = NULL;
 
 	ino->last_used = jiffies;
 
@@ -87,7 +89,7 @@
 
 	kfree(sbi);
 
-	DPRINTK(("autofs: shutting down\n"));
+	DPRINTK(("autofs4: shutting down\n"));
 }
 
 static int autofs4_statfs(struct super_block *sb, struct statfs *buf);
@@ -181,12 +183,13 @@
 	struct file * pipe;
 	int pipefd;
 	struct autofs_sb_info *sbi;
+	struct autofs_info *ino;
 	int minproto, maxproto;
 
 	sbi = (struct autofs_sb_info *) kmalloc(sizeof(*sbi), GFP_KERNEL);
 	if ( !sbi )
 		goto fail_unlock;
-	DPRINTK(("autofs: starting up, sbi = %p\n",sbi));
+	DPRINTK(("autofs4: starting up, sbi = %p\n",sbi));
 
 	memset(sbi, 0, sizeof(*sbi));
 
@@ -197,7 +200,10 @@
 	sbi->oz_pgrp = current->pgrp;
 	sbi->sb = s;
 	sbi->version = 0;
+	sbi->sub_version = 0;
 	sbi->queues = NULL;
+	sbi->reghost_enabled = 0;
+	sbi->needs_reghost = 0;
 	s->s_blocksize = 1024;
 	s->s_blocksize_bits = 10;
 	s->s_magic = AUTOFS_SUPER_MAGIC;
@@ -206,7 +212,9 @@
 	/*
 	 * Get the root inode and dentry, but defer checking for errors.
 	 */
-	root_inode = autofs4_get_inode(s, autofs4_mkroot(sbi));
+	ino = autofs4_mkroot(sbi);
+	root_inode = autofs4_get_inode(s, ino);
+	kfree(ino);
 	root_inode->i_op = &autofs4_root_inode_operations;
 	root_inode->i_fop = &autofs4_root_operations;
 	root = d_alloc_root(root_inode);
@@ -220,14 +228,14 @@
 			  &root_inode->i_uid, &root_inode->i_gid,
 			  &sbi->oz_pgrp,
 			  &minproto, &maxproto)) {
-		printk("autofs: called with bogus options\n");
+		printk("autofs4: called with bogus options\n");
 		goto fail_dput;
 	}
 
 	/* Couldn't this be tested earlier? */
 	if (maxproto < AUTOFS_MIN_PROTO_VERSION ||
 	    minproto > AUTOFS_MAX_PROTO_VERSION) {
-		printk("autofs: kernel does not match daemon version "
+		printk("autofs4: kernel does not match daemon version "
 		       "daemon (%d, %d) kernel (%d, %d)\n",
 			minproto, maxproto,
 			AUTOFS_MIN_PROTO_VERSION, AUTOFS_MAX_PROTO_VERSION);
@@ -235,12 +243,13 @@
 	}
 
 	sbi->version = maxproto > AUTOFS_MAX_PROTO_VERSION ? AUTOFS_MAX_PROTO_VERSION : maxproto;
+	sbi->sub_version =  AUTOFS_PROTO_SUBVERSION;
 
-	DPRINTK(("autofs: pipe fd = %d, pgrp = %u\n", pipefd, sbi->oz_pgrp));
+	DPRINTK(("autofs4: pipe fd = %d, pgrp = %u\n", pipefd, sbi->oz_pgrp));
 	pipe = fget(pipefd);
 	
 	if ( !pipe ) {
-		printk("autofs: could not open pipe file descriptor\n");
+		printk("autofs4: could not open pipe file descriptor\n");
 		goto fail_dput;
 	}
 	if ( !pipe->f_op || !pipe->f_op->write )
@@ -257,7 +266,7 @@
 	 * Failure ... clean up.
 	 */
 fail_fput:
-	printk("autofs: pipe file descriptor does not contain proper ops\n");
+	printk("autofs4: pipe file descriptor does not contain proper ops\n");
 	/*
 	 * fput() can block, so we clear the super block first.
 	 */
@@ -270,7 +279,7 @@
 	dput(root);
 	goto fail_free;
 fail_iput:
-	printk("autofs: get root dentry failed\n");
+	printk("autofs4: get root dentry failed\n");
 	/*
 	 * iput() can block, so we clear the super block first.
 	 */
@@ -314,7 +323,7 @@
 	if (S_ISDIR(inf->mode)) {
 		inode->i_nlink = 2;
 		inode->i_op = &autofs4_dir_inode_operations;
-		inode->i_fop = &dcache_dir_ops;
+		inode->i_fop = &autofs4_dir_operations;
 	} else if (S_ISLNK(inf->mode)) {
 		inode->i_size = inf->size;
 		inode->i_op = &autofs4_symlink_inode_operations;
diff -Nur linux-2.4.20.dist/fs/autofs4/Makefile autofs4-2.4/fs/autofs4/Makefile
--- linux-2.4.20.dist/fs/autofs4/Makefile	2000-12-30 06:07:23.000000000 +0800
+++ autofs4-2.4/fs/autofs4/Makefile	2003-11-09 19:33:53.000000000 +0800
@@ -6,7 +6,7 @@
 
 O_TARGET := autofs4.o
 
-obj-y   := init.o inode.o root.o symlink.o waitq.o expire.o
+obj-y   := init.o inode.o root.o symlink.o waitq.o expire.o readdir.o
 
 obj-m   := $(O_TARGET)
 
diff -Nur linux-2.4.20.dist/fs/autofs4/readdir.c autofs4-2.4/fs/autofs4/readdir.c
--- linux-2.4.20.dist/fs/autofs4/readdir.c	1970-01-01 08:00:00.000000000 +0800
+++ autofs4-2.4/fs/autofs4/readdir.c	2003-11-09 19:33:53.000000000 +0800
@@ -0,0 +1,73 @@
+/*
+ *  linux/fs/readdir.c
+ *
+ *  Copyright (C) 1995  Linus Torvalds
+ */
+
+#include <linux/sched.h>
+#include <linux/file.h>
+#include <linux/smp_lock.h>
+
+/*
+ * Directory is locked and all positive dentries in it are safe, since
+ * for ramfs-type trees they can't go away without unlink() or rmdir(),
+ * both impossible due to the lock on directory.
+ */
+
+int autofs4_dcache_readdir(struct file * filp, void * dirent, filldir_t filldir)
+{
+	int i;
+	struct dentry *dentry = filp->f_dentry;
+
+	i = filp->f_pos;
+	switch (i) {
+		case 0:
+			if (filldir(dirent, ".", 1, i, dentry->d_inode->i_ino, DT_DIR) < 0)
+				break;
+			i++;
+			filp->f_pos++;
+			/* fallthrough */
+		case 1:
+			if (filldir(dirent, "..", 2, i, dentry->d_parent->d_inode->i_ino, DT_DIR) < 0)
+				break;
+			i++;
+			filp->f_pos++;
+			/* fallthrough */
+		default: {
+			struct list_head *list;
+			int j = i-2;
+
+			spin_lock(&dcache_lock);
+			list = dentry->d_subdirs.next;
+
+			for (;;) {
+				if (list == &dentry->d_subdirs) {
+					spin_unlock(&dcache_lock);
+					return 0;
+				}
+				if (!j)
+					break;
+				j--;
+				list = list->next;
+			}
+
+			while(1) {
+				struct dentry *de = list_entry(list, struct dentry, d_child);
+
+				if (!list_empty(&de->d_hash) && de->d_inode) {
+					spin_unlock(&dcache_lock);
+					if (filldir(dirent, de->d_name.name, de->d_name.len, filp->f_pos, de->d_inode->i_ino, DT_UNKNOWN) < 0)
+						break;
+					spin_lock(&dcache_lock);
+				}
+				filp->f_pos++;
+				list = list->next;
+				if (list != &dentry->d_subdirs)
+					continue;
+				spin_unlock(&dcache_lock);
+				break;
+			}
+		}
+	}
+	return 0;
+}
diff -Nur linux-2.4.20.dist/fs/autofs4/root.c autofs4-2.4/fs/autofs4/root.c
--- linux-2.4.20.dist/fs/autofs4/root.c	2002-08-03 08:39:45.000000000 +0800
+++ autofs4-2.4/fs/autofs4/root.c	2003-11-09 19:33:53.000000000 +0800
@@ -4,6 +4,7 @@
  *
  *  Copyright 1997-1998 Transmeta Corporation -- All Rights Reserved
  *  Copyright 1999-2000 Jeremy Fitzhardinge <jeremy@goop.org>
+ *  Copyright 2001-2003 Ian Kent <raven@themaw.net>
  *
  * This file is part of the Linux kernel and is made available under
  * the terms of the GNU General Public License, version 2, or at your
@@ -16,6 +17,10 @@
 #include <linux/param.h>
 #include <linux/sched.h>
 #include <linux/smp_lock.h>
+#include <linux/file.h>
+#include <linux/limits.h>
+#include <linux/iobuf.h>
+#include <linux/module.h>
 #include "autofs_i.h"
 
 static struct dentry *autofs4_dir_lookup(struct inode *,struct dentry *);
@@ -24,18 +29,26 @@
 static int autofs4_dir_rmdir(struct inode *,struct dentry *);
 static int autofs4_dir_mkdir(struct inode *,struct dentry *,int);
 static int autofs4_root_ioctl(struct inode *, struct file *,unsigned int,unsigned long);
+static int autofs4_dir_open(struct inode *inode, struct file *file);
+static int autofs4_dir_close(struct inode *inode, struct file *file);
+static int autofs4_dir_readdir(struct file * filp, void * dirent, filldir_t filldir);
+static int autofs4_root_readdir(struct file * filp, void * dirent, filldir_t filldir);
 static struct dentry *autofs4_root_lookup(struct inode *,struct dentry *);
+int autofs4_dcache_readdir(struct file *, void *, filldir_t);
 
 struct file_operations autofs4_root_operations = {
-	open:		dcache_dir_open,
-	release:	dcache_dir_close,
-	llseek:		dcache_dir_lseek,
 	read:		generic_read_dir,
-	readdir:	dcache_readdir,
-	fsync:		dcache_dir_fsync,
+	readdir:	autofs4_root_readdir,
 	ioctl:		autofs4_root_ioctl,
 };
 
+struct file_operations autofs4_dir_operations = {
+	open:		autofs4_dir_open,
+	release:	autofs4_dir_close,
+	read:		generic_read_dir,
+	readdir:	autofs4_dir_readdir,
+};
+
 struct inode_operations autofs4_root_inode_operations = {
 	lookup:		autofs4_root_lookup,
 	unlink:		autofs4_dir_unlink,
@@ -54,10 +67,11 @@
 
 /* Update usage from here to top of tree, so that scan of
    top-level directories will give a useful result */
-static void autofs4_update_usage(struct dentry *dentry)
+static inline void autofs4_update_usage(struct dentry *dentry)
 {
 	struct dentry *top = dentry->d_sb->s_root;
 
+	spin_lock(&dcache_lock);
 	for(; dentry != top; dentry = dentry->d_parent) {
 		struct autofs_info *ino = autofs4_dentry_ino(dentry);
 
@@ -66,11 +80,210 @@
 			ino->last_used = jiffies;
 		}
 	}
+	spin_unlock(&dcache_lock);
+}
+
+static int autofs4_root_readdir(struct file *file, void *dirent, filldir_t filldir)
+{
+	struct autofs_sb_info *sbi = autofs4_sbi(file->f_dentry->d_sb);
+	int oz_mode = autofs4_oz_mode(sbi);
+
+	DPRINTK(("autofs4_root_readdir called, filp->f_pos = %lld\n", file->f_pos));
+
+	/*
+	 * Don't set reghost flag if:
+	 * 1) f_pos is larger than zero -- we've already been here.
+	 * 2) we haven't even enabled reghosting in the 1st place.
+	 * 3) this is the daemon doing a readdir
+	 */
+	if ( oz_mode && file->f_pos == 0 && sbi->reghost_enabled )
+		sbi->needs_reghost = 1;
+
+	DPRINTK(("autofs4_root_readdir: needs_reghost = %d\n", sbi->needs_reghost));
+
+	return autofs4_dcache_readdir(file, dirent, filldir);
+}
+
+static void autofs4_check_pwd(struct file *file, struct file *fp)
+{
+	struct dentry *pwd = file->f_dentry;
+	struct dentry *new_pwd = fp->f_dentry;
+	struct vfsmount *new_mnt = fp->f_vfsmnt;
+
+	/* dentry is a pwd of mountpoint so move to it */
+	if ( current->fs->pwd == pwd )
+		set_fs_pwd(current->fs, new_mnt, new_pwd);
+
+	/* dentry is root of a chrooted mountpoint so move to it */
+	if ( current->fs->root == pwd ) {
+		set_fs_root(current->fs, new_mnt, new_pwd);
+		/* alternate os ABI not supported  */
+		/* set_fs_altroot(); */
+	}
+}
+
+static struct file *autofs4_dentry_open(struct dentry *dentry, struct vfsmount *mnt, int flags)
+{
+	struct vfsmount *tmp, *dir_mnt;
+	struct dentry *dir_dentry;
+	struct file *fp;
+	int status;
+
+	DPRINTK(("autofs4_dentry_open: dentry=%p %.*s\n",
+		 dentry, dentry->d_name.len, dentry->d_name.name));
+
+	spin_lock(&dcache_lock);
+	tmp = lookup_mnt(mnt, dentry);
+	if ( !tmp ) {
+		spin_unlock(&dcache_lock);
+		return ERR_PTR(-ENOENT);
+	}
+	dir_mnt = mntget(tmp);
+	dir_dentry = dget(dir_mnt->mnt_root);
+	spin_unlock(&dcache_lock);
+	
+	fp = dentry_open(dir_dentry, dir_mnt, flags);
+	if ( !IS_ERR(fp) ) {
+		status = permission( fp->f_dentry->d_inode, MAY_READ );
+		if ( status ) {
+			filp_close(fp, current->files);
+			return ERR_PTR(status);
+		}
+	}
+	return fp;
+}
+
+static int autofs4_dir_open(struct inode *inode, struct file *file)
+{
+	struct dentry *dentry = file->f_dentry;
+	struct vfsmount *mnt = file->f_vfsmnt;
+	struct autofs_sb_info *sbi = autofs4_sbi(dentry->d_sb);
+	int status;
+
+	DPRINTK(("autofs4_dir_open: file=%p dentry=%p %.*s\n",
+		 file, dentry, dentry->d_name.len, dentry->d_name.name));
+
+	if (autofs4_oz_mode(sbi))
+		goto out;
+
+	if (autofs4_ispending(dentry)) {
+		DPRINTK(("autofs4_dir_open: dentry busy\n"));
+		return -EBUSY;
+	}
+
+	if (!d_mountpoint(dentry) && dentry->d_op && dentry->d_op->d_revalidate) {
+		int empty;
+
+		/* In case there are stale directory dentrys from a failed mount */
+		spin_lock(&dcache_lock);
+		empty = list_empty(&dentry->d_subdirs);
+		spin_unlock(&dcache_lock);
+
+		if (!empty)
+			d_invalidate(dentry);
+
+		status = (dentry->d_op->d_revalidate)(dentry, LOOKUP_CONTINUE);
+
+		if ( !status )
+			return -ENOENT;
+	}
+
+	if ( d_mountpoint(dentry) ) {
+		struct autofs_info *ino = autofs4_dentry_ino(dentry);
+		struct file *fp;
+
+		if (ino && atomic_read(&ino->fp_count)) {
+			atomic_inc(&ino->fp_count);
+			return 0;
+		}
+
+		down(&dentry->d_inode->i_sem);
+		fp = autofs4_dentry_open(dentry, mnt, file->f_flags);
+		status = PTR_ERR(fp);
+		if ( IS_ERR(fp) ) {
+			up(&dentry->d_inode->i_sem);
+			return status;
+		}
+		atomic_inc(&ino->fp_count);
+		autofs4_check_pwd(file, fp);
+		ino->fp = fp;
+		up(&dentry->d_inode->i_sem);
+	}
+out:
+	return 0;
+}
+
+static int autofs4_dir_close(struct inode *inode, struct file *file)
+{
+	struct dentry *dentry = file->f_dentry;
+	struct autofs_sb_info *sbi = autofs4_sbi(dentry->d_sb);
+
+	DPRINTK(("autofs4_dir_close: file=%p dentry=%p %.*s\n",
+		 file, dentry, dentry->d_name.len, dentry->d_name.name));
+
+	if ( autofs4_oz_mode(sbi) )
+		goto out;
+
+	if ( autofs4_ispending(dentry) ) {
+		DPRINTK(("autofs4_dir_close: dentry busy\n"));
+		return -EBUSY;
+	}
+
+	if ( d_mountpoint(dentry) ) {
+		struct autofs_info *ino = autofs4_dentry_ino(dentry);
+
+		if (!(ino && atomic_read(&ino->fp_count)))
+			return -ENOENT;
+
+		if (atomic_dec_and_test(&ino->fp_count)) {
+			down(&dentry->d_inode->i_sem);
+			filp_close(ino->fp, current->files);
+			ino->fp = NULL;
+			up(&dentry->d_inode->i_sem);
+		}
+	}
+out:
+	return 0;
+}
+
+static int autofs4_dir_readdir(struct file *file, void *dirent, filldir_t filldir)
+{
+	struct dentry *dentry = file->f_dentry;
+	struct autofs_sb_info *sbi = autofs4_sbi(dentry->d_sb);
+	int status;
+
+	DPRINTK(("autofs4_readdir: file=%p dentry=%p %.*s\n",
+		 file, dentry, dentry->d_name.len, dentry->d_name.name));
+
+	if ( autofs4_oz_mode(sbi) )
+		goto out;
+
+	if ( autofs4_ispending(dentry) ) {
+		DPRINTK(("autofs4_readdir: dentry busy\n"));
+		return -EBUSY;
+	}
+
+	if ( d_mountpoint(dentry) ) {
+		struct autofs_info *ino = autofs4_dentry_ino(dentry);
+
+		if (!(ino && atomic_read(&ino->fp_count)))
+			return -ENOENT;
+
+		/* dentry->d_inode->i_sem held by calling vfs_readdir */
+		ino->fp->f_pos = file->f_pos;
+		status = vfs_readdir(ino->fp, filldir, dirent);
+		file->f_pos = ino->fp->f_pos;
+		if ( status )
+			autofs4_copy_atime(file, ino->fp);
+		return status;
+	}
+out:
+	return autofs4_dcache_readdir(file, dirent, filldir);
 }
 
 static int try_to_fill_dentry(struct dentry *dentry, 
 			      struct super_block *sb,
-			      struct autofs_sb_info *sbi)
+			      struct autofs_sb_info *sbi, int flags)
 {
 	struct autofs_info *de_info = autofs4_dentry_ino(dentry);
 	int status = 0;
@@ -79,12 +292,11 @@
            when expiration is done to trigger mount request with a new
            dentry */
 	if (de_info && (de_info->flags & AUTOFS_INF_EXPIRING)) {
-		DPRINTK(("try_to_fill_entry: waiting for expire %p name=%.*s, flags&PENDING=%s de_info=%p de_info->flags=%x\n",
-			 dentry, dentry->d_name.len, dentry->d_name.name, 
-			 dentry->d_flags & DCACHE_AUTOFS_PENDING?"t":"f",
-			 de_info, de_info?de_info->flags:0));
-		status = autofs4_wait(sbi, &dentry->d_name, NFY_NONE);
-		
+		DPRINTK(("try_to_fill_entry: waiting for expire %p name=%.*s\n",
+			 dentry, dentry->d_name.len, dentry->d_name.name));
+
+		status = autofs4_wait(sbi, dentry, NFY_NONE);
+
 		DPRINTK(("try_to_fill_entry: expire done status=%d\n", status));
 		
 		return 0;
@@ -94,12 +306,12 @@
 		 dentry, dentry->d_name.len, dentry->d_name.name, dentry->d_inode));
 
 	/* Wait for a pending mount, triggering one if there isn't one already */
-	while(dentry->d_inode == NULL) {
-		DPRINTK(("try_to_fill_entry: waiting for mount name=%.*s, de_info=%p de_info->flags=%x\n",
-			 dentry->d_name.len, dentry->d_name.name, 
-			 de_info, de_info?de_info->flags:0));
-		status = autofs4_wait(sbi, &dentry->d_name, NFY_MOUNT);
-		 
+	if (dentry->d_inode == NULL) {
+		DPRINTK(("try_to_fill_entry: waiting for mount name=%.*s\n",
+			 dentry->d_name.len, dentry->d_name.name));
+
+		status = autofs4_wait(sbi, dentry, NFY_MOUNT);
+
 		DPRINTK(("try_to_fill_entry: mount done status=%d\n", status));
 
 		if (status && dentry->d_inode)
@@ -114,19 +326,21 @@
 			/* Return a negative dentry, but leave it "pending" */
 			return 1;
 		}
-	}
+	/* Trigger mount for path component or follow link */
+	} else if ( flags & LOOKUP_CONTINUE || current->link_count ) {
+		DPRINTK(("try_to_fill_entry: waiting for mount name=%.*s\n",
+			 dentry->d_name.len, dentry->d_name.name));
 
-	/* If this is an unused directory that isn't a mount point,
-	   bitch at the daemon and fix it in user space */
-	spin_lock(&dcache_lock);
-	if (S_ISDIR(dentry->d_inode->i_mode) &&
-	    !d_mountpoint(dentry) && 
-	    list_empty(&dentry->d_subdirs)) {
-		DPRINTK(("try_to_fill_entry: mounting existing dir\n"));
-		spin_unlock(&dcache_lock);
-		return autofs4_wait(sbi, &dentry->d_name, NFY_MOUNT) == 0;
+		dentry->d_flags |= DCACHE_AUTOFS_PENDING;
+		status = autofs4_wait(sbi, dentry, NFY_MOUNT);
+
+		DPRINTK(("try_to_fill_entry: mount done status=%d\n", status));
+
+		if ( status ) {
+			dentry->d_flags &= ~DCACHE_AUTOFS_PENDING;
+			return 0;
+		}
 	}
-	spin_unlock(&dcache_lock);
 
 	/* We don't update the usages for the autofs daemon itself, this
 	   is necessary for recursive autofs mounts */
@@ -137,46 +351,46 @@
 	return 1;
 }
 
-
 /*
  * Revalidate is called on every cache lookup.  Some of those
  * cache lookups may actually happen while the dentry is not
  * yet completely filled in, and revalidate has to delay such
  * lookups..
  */
-static int autofs4_root_revalidate(struct dentry * dentry, int flags)
+static int autofs4_revalidate(struct dentry * dentry, int flags)
 {
 	struct inode * dir = dentry->d_parent->d_inode;
 	struct autofs_sb_info *sbi = autofs4_sbi(dir->i_sb);
-	struct autofs_info *ino;
 	int oz_mode = autofs4_oz_mode(sbi);
+	int status = 1;
+
+	DPRINTK(("autofs4_revalidate: dentry=%p %.*s flags=%d\n",
+		 dentry, dentry->d_name.len, dentry->d_name.name, flags));
 
 	/* Pending dentry */
 	if (autofs4_ispending(dentry)) {
-		if (autofs4_oz_mode(sbi))
-			return 1;
-		else
-			return try_to_fill_dentry(dentry, dir->i_sb, sbi);
+		if ( !oz_mode )
+			status = try_to_fill_dentry(dentry, dir->i_sb, sbi, flags);
+		return status;
 	}
 
 	/* Negative dentry.. invalidate if "old" */
-	if (dentry->d_inode == NULL)
-		return (dentry->d_time - jiffies <= AUTOFS_NEGATIVE_TIMEOUT);
-
-	ino = autofs4_dentry_ino(dentry);
+	if (dentry->d_inode == NULL) {
+		status = (dentry->d_time - jiffies <= AUTOFS_NEGATIVE_TIMEOUT);
+		return status;
+	}
 
 	/* Check for a non-mountpoint directory with no contents */
 	spin_lock(&dcache_lock);
 	if (S_ISDIR(dentry->d_inode->i_mode) &&
 	    !d_mountpoint(dentry) && 
 	    list_empty(&dentry->d_subdirs)) {
-		DPRINTK(("autofs_root_revalidate: dentry=%p %.*s, emptydir\n",
+		DPRINTK(("autofs4_revalidate: dentry=%p %.*s, emptydir\n",
 			 dentry, dentry->d_name.len, dentry->d_name.name));
 		spin_unlock(&dcache_lock);
-		if (oz_mode)
-			return 1;
-		else
-			return try_to_fill_dentry(dentry, dir->i_sb, sbi);
+		if (!oz_mode)
+			status = try_to_fill_dentry(dentry, dir->i_sb, sbi, flags);
+		return status;
 	}
 	spin_unlock(&dcache_lock);
 
@@ -184,25 +398,13 @@
 	if (!oz_mode)
 		autofs4_update_usage(dentry);
 
-	return 1;
-}
-
-static int autofs4_revalidate(struct dentry *dentry, int flags)
-{
-	struct autofs_sb_info *sbi = autofs4_sbi(dentry->d_sb);
-
-	if (!autofs4_oz_mode(sbi))
-		autofs4_update_usage(dentry);
-
-	return 1;
+	return status;
 }
 
 static void autofs4_dentry_release(struct dentry *de)
 {
 	struct autofs_info *inf;
 
-	lock_kernel();
-
 	DPRINTK(("autofs4_dentry_release: releasing %p\n", de));
 
 	inf = autofs4_dentry_ino(de);
@@ -214,13 +416,11 @@
 
 		autofs4_free_ino(inf);
 	}
-
-	unlock_kernel();
 }
 
 /* For dentries of directories in the root dir */
 static struct dentry_operations autofs4_root_dentry_operations = {
-	d_revalidate:	autofs4_root_revalidate,
+	d_revalidate:	autofs4_revalidate,
 	d_release:	autofs4_dentry_release,
 };
 
@@ -230,16 +430,114 @@
 	d_release:	autofs4_dentry_release,
 };
 
-/* Lookups in non-root dirs never find anything - if it's there, it's
-   already in the dcache */
+/*
+ * This subroutine is taken straight out of fs/namei.c since we need
+ * to do the lookup again in exaclty the same way.
+ */
+static struct dentry * real_lookup(struct dentry * parent, struct qstr * name, int flags)
+{
+	struct dentry * result;
+	struct inode *dir = parent->d_inode;
+
+	down(&dir->i_sem);
+	result = d_lookup(parent, name);
+	if (!result) {
+		struct dentry * dentry = d_alloc(parent, name);
+		result = ERR_PTR(-ENOMEM);
+		if (dentry) {
+			lock_kernel();
+			result = dir->i_op->lookup(dir, dentry);
+			unlock_kernel();
+			if (result)
+				dput(dentry);
+			else
+				result = dentry;
+		}
+		up(&dir->i_sem);
+		return result;
+	}
+
+	up(&dir->i_sem);
+	if (result->d_op && result->d_op->d_revalidate) {
+		if (!result->d_op->d_revalidate(result, flags) && !d_invalidate(result)) {
+			dput(result);
+			result = ERR_PTR(-ENOENT);
+		}
+	}
+	return result;
+}
+
+static int is_autofs4_mountpoint(struct dentry *parent)
+{
+	struct list_head *tmp;
+
+	DPRINTK(("autofs4_is_mountpoint: parent=%p %.*s\n",
+		parent, parent->d_name.len, parent->d_name.name));
+
+	spin_lock(&dcache_lock);
+	tmp = parent->d_subdirs.next;
+	while ( tmp != &parent->d_subdirs ) {
+		struct dentry * dentry = list_entry(tmp, struct dentry, d_child);
+
+		tmp = tmp->next;
+
+		if (is_autofs4_dentry(dentry) && !d_unhashed(dentry)) {
+			spin_unlock(&dcache_lock);
+			return 0;
+		}
+	}
+	spin_unlock(&dcache_lock);
+	return 1;
+}
+
+/* Lookups in non root directories */
 static struct dentry *autofs4_dir_lookup(struct inode *dir, struct dentry *dentry)
 {
-#if 0
-	DPRINTK(("autofs_dir_lookup: ignoring lookup of %.*s/%.*s\n",
+	struct dentry *parent = dentry->d_parent;
+	struct autofs_sb_info *sbi = autofs4_sbi(parent->d_sb);
+	struct qstr *name = &dentry->d_name;
+	struct vfsmount *mnt = NULL;
+	int status = 0;
+
+	DPRINTK(("autofs4_dir_lookup: lookup of %p %.*s/%.*s\n",
+		 dentry->d_parent, 
 		 dentry->d_parent->d_name.len, dentry->d_parent->d_name.name,
 		 dentry->d_name.len, dentry->d_name.name));
-#endif
 
+	if (autofs4_oz_mode(sbi))
+		goto out;
+
+	if (!is_autofs4_mountpoint(parent))
+		goto out;
+
+	/* If our pwd or root dentry is an autofs4 leaf node
+	 * we need to mount it and redo the lookup */
+	if (!d_mountpoint(parent)) {
+		DPRINTK(("autofs4_dir_lookup: waiting for mount name=%.*s\n",
+			parent->d_name.len, parent->d_name.name));
+
+		up(&dir->i_sem);
+		status = try_to_fill_dentry(parent, dir->i_sb, sbi, LOOKUP_CONTINUE);
+		down(&dir->i_sem);
+
+		DPRINTK(("autofs4_dir_lookup: mount done status=%d\n", status));
+
+		if ( !status )
+			goto out;
+	}
+
+	read_lock(&current->fs->lock);
+	if (current->fs->pwd == parent )
+		mnt = lookup_mnt(current->fs->pwdmnt, parent);
+	else if (current->fs->root == parent)
+		mnt = lookup_mnt(current->fs->rootmnt, parent);
+	read_unlock(&current->fs->lock);
+
+	if ( !mnt )
+		goto out;
+
+	return real_lookup(mnt->mnt_root, name, 0);
+out:
 	dentry->d_fsdata = NULL;
 	d_add(dentry, NULL);
 	return NULL;
@@ -251,7 +549,7 @@
 	struct autofs_sb_info *sbi;
 	int oz_mode;
 
-	DPRINTK(("autofs_root_lookup: name = %.*s\n", 
+	DPRINTK(("autofs4_root_lookup: name = %.*s\n", 
 		 dentry->d_name.len, dentry->d_name.name));
 
 	if (dentry->d_name.len > NAME_MAX)
@@ -260,7 +558,8 @@
 	sbi = autofs4_sbi(dir->i_sb);
 
 	oz_mode = autofs4_oz_mode(sbi);
-	DPRINTK(("autofs_lookup: pid = %u, pgrp = %u, catatonic = %d, oz_mode = %d\n",
+
+	DPRINTK(("autofs4_root_lookup: pid = %u, pgrp = %u, catatonic = %d, oz_mode = %d\n",
 		 current->pid, current->pgrp, sbi->catatonic, oz_mode));
 
 	/*
@@ -316,7 +615,7 @@
 	struct inode *inode;
 	char *cp;
 
-	DPRINTK(("autofs_dir_symlink: %s <- %.*s\n", symname, 
+	DPRINTK(("autofs4_dir_symlink: %s <- %.*s\n", symname, 
 		 dentry->d_name.len, dentry->d_name.name));
 
 	if (!autofs4_oz_mode(sbi))
@@ -366,7 +665,7 @@
  * If a process is blocked on the dentry waiting for the expire to finish,
  * it will invalidate the dentry and try to mount with a new one.
  *
- * Also see autofs_dir_rmdir().. 
+ * Also see autofs4_dir_rmdir().. 
  */
 static int autofs4_dir_unlink(struct inode *dir, struct dentry *dentry)
 {
@@ -416,8 +715,6 @@
 	return 0;
 }
 
-
-
 static int autofs4_dir_mkdir(struct inode *dir, struct dentry *dentry, int mode)
 {
 	struct autofs_sb_info *sbi = autofs4_sbi(dir->i_sb);
@@ -427,7 +724,7 @@
 	if ( !autofs4_oz_mode(sbi) )
 		return -EACCES;
 
-	DPRINTK(("autofs_dir_mkdir: dentry %p, creating %.*s\n",
+	DPRINTK(("autofs4_dir_mkdir: dentry %p, creating %.*s\n",
 		 dentry, dentry->d_name.len, dentry->d_name.name));
 
 	ino = autofs4_init_ino(ino, sbi, S_IFDIR | 0555);
@@ -451,6 +748,19 @@
 	return 0;
 }
 
+/* 
+ * Identify autofs_dentries - this is so we can tell if there's
+ * an extra dentry refcount or not.  We only hold a refcount on the
+ * dentry if its non-negative (ie, d_inode != NULL)
+ */
+int is_autofs4_dentry(struct dentry *dentry)
+{
+	return dentry && dentry->d_inode &&
+		(dentry->d_op == &autofs4_root_dentry_operations ||
+		 dentry->d_op == &autofs4_dentry_operations) &&
+		dentry->d_fsdata != NULL;
+}
+
 /* Get/set timeout ioctl() operation */
 static inline int autofs4_get_set_timeout(struct autofs_sb_info *sbi,
 					 unsigned long *p)
@@ -476,19 +786,67 @@
 	return put_user(sbi->version, p);
 }
 
-/* Identify autofs_dentries - this is so we can tell if there's
-   an extra dentry refcount or not.  We only hold a refcount on the
-   dentry if its non-negative (ie, d_inode != NULL)
-*/
-int is_autofs4_dentry(struct dentry *dentry)
+/* Return protocol sub version */
+static inline int autofs4_get_protosubver(struct autofs_sb_info *sbi, int *p)
 {
-	return dentry && dentry->d_inode &&
-		(dentry->d_op == &autofs4_root_dentry_operations ||
-		 dentry->d_op == &autofs4_dentry_operations) &&
-		dentry->d_fsdata != NULL;
+	return put_user(sbi->sub_version, p);
 }
 
 /*
+ * Tells the daemon whether we need to reghost or not. Also, clears
+ * the reghost_needed flag.
+ */
+static inline int autofs4_ask_reghost(struct autofs_sb_info *sbi, int *p)
+{
+	int status;
+
+	DPRINTK(("autofs_ask_reghost: returning %d\n", sbi->needs_reghost));
+
+	status = put_user(sbi->needs_reghost, p);
+	if ( status )
+		return status;
+
+	 sbi->needs_reghost = 0;
+	 return 0;
+}
+
+/*
+ * Enable / Disable reghosting ioctl() operation
+ */
+static inline int autofs4_toggle_reghost(struct autofs_sb_info *sbi, int *p)
+{
+	int status;
+	int val;
+
+	status = get_user(val, p);
+
+	DPRINTK(("autofs4_toggle_reghost: reghost = %d\n", val));
+
+	if (status)
+		return status;
+
+	/* turn on/off reghosting, with the val */
+	sbi->reghost_enabled = val;
+	return 0;
+}
+
+/*
+ * Tells the daemon whether we can umaont the autofs mount.
+ */
+static inline int autofs4_ask_umount(struct vfsmount *mnt, int *p)
+{
+	int status = 0;
+
+	if ( may_umount(mnt) == 0 )
+		status = 1;
+
+	DPRINTK(("autofs_ask_umount: returning %d\n", status));
+
+	status = put_user(status, p);
+
+	return status;
+}
+/*
  * ioctl()'s on the root directory is the chief method for the daemon to
  * generate kernel reactions
  */
@@ -497,7 +855,7 @@
 {
 	struct autofs_sb_info *sbi = autofs4_sbi(inode->i_sb);
 
-	DPRINTK(("autofs_ioctl: cmd = 0x%08x, arg = 0x%08lx, sbi = %p, pgrp = %u\n",
+	DPRINTK(("autofs4_ioctl: cmd = 0x%08x, arg = 0x%08lx, sbi = %p, pgrp = %u\n",
 		 cmd,arg,sbi,current->pgrp));
 
 	if ( _IOC_TYPE(cmd) != _IOC_TYPE(AUTOFS_IOC_FIRST) ||
@@ -508,28 +866,47 @@
 		return -EPERM;
 	
 	switch(cmd) {
-	case AUTOFS_IOC_READY:	/* Wait queue: go ahead and retry */
-		return autofs4_wait_release(sbi,(autofs_wqt_t)arg,0);
-	case AUTOFS_IOC_FAIL:	/* Wait queue: fail with ENOENT */
-		return autofs4_wait_release(sbi,(autofs_wqt_t)arg,-ENOENT);
-	case AUTOFS_IOC_CATATONIC: /* Enter catatonic mode (daemon shutdown) */
-		autofs4_catatonic_mode(sbi);
-		return 0;
-	case AUTOFS_IOC_PROTOVER: /* Get protocol version */
-		return autofs4_get_protover(sbi, (int *)arg);
-	case AUTOFS_IOC_SETTIMEOUT:
-		return autofs4_get_set_timeout(sbi,(unsigned long *)arg);
-
-	/* return a single thing to expire */
-	case AUTOFS_IOC_EXPIRE:
-		return autofs4_expire_run(inode->i_sb,filp->f_vfsmnt,sbi,
-					  (struct autofs_packet_expire *)arg);
-	/* same as above, but can send multiple expires through pipe */
-	case AUTOFS_IOC_EXPIRE_MULTI:
-		return autofs4_expire_multi(inode->i_sb,filp->f_vfsmnt,sbi,
-					    (int *)arg);
+		case AUTOFS_IOC_READY:	/* Wait queue: go ahead and retry */
+			return autofs4_wait_release(sbi, (autofs_wqt_t)arg, 0);
+
+		case AUTOFS_IOC_FAIL:	/* Wait queue: fail with ENOENT */
+			return autofs4_wait_release(sbi, (autofs_wqt_t)arg, -ENOENT);
+
+		case AUTOFS_IOC_CATATONIC: /* Enter catatonic mode (daemon shutdown) */
+			autofs4_catatonic_mode(sbi);
+			return 0;
+
+		case AUTOFS_IOC_PROTOVER: /* Get protocol version */
+			return autofs4_get_protover(sbi, (int *)arg);
+
+		case AUTOFS_IOC_PROTOSUBVER: /* Get protocol version */
+			return autofs4_get_protosubver(sbi, (int *) arg);
+
+		case AUTOFS_IOC_SETTIMEOUT:
+			return autofs4_get_set_timeout(sbi, (unsigned long *) arg);
+
+		case AUTOFS_IOC_TOGGLEREGHOST:
+			return autofs4_toggle_reghost(sbi, (int *) arg);
+
+		case AUTOFS_IOC_ASKREGHOST:
+			return autofs4_ask_reghost(sbi, (int *) arg);
+
+		case AUTOFS_IOC_ASKUMOUNT:
+			return autofs4_ask_umount(filp->f_vfsmnt, (int *) arg);
+
+		/* return a single thing to expire */
+		case AUTOFS_IOC_EXPIRE:
+			return autofs4_expire_run(
+				inode->i_sb, filp->f_vfsmnt, sbi,
+			 	(struct autofs_packet_expire *)arg);
+
+		/* same as above, but can send multiple expires through pipe */
+		case AUTOFS_IOC_EXPIRE_MULTI:
+			return autofs4_expire_multi(inode->i_sb,
+						filp->f_vfsmnt,
+						sbi, (int *) arg);
 
-	default:
-		return -ENOSYS;
+		default:
+			return -ENOSYS;
 	}
 }
diff -Nur linux-2.4.20.dist/fs/autofs4/waitq.c autofs4-2.4/fs/autofs4/waitq.c
--- linux-2.4.20.dist/fs/autofs4/waitq.c	2001-02-10 03:29:44.000000000 +0800
+++ autofs4-2.4/fs/autofs4/waitq.c	2003-11-09 19:33:53.000000000 +0800
@@ -3,6 +3,7 @@
  * linux/fs/autofs/waitq.c
  *
  *  Copyright 1997-1998 Transmeta Corporation -- All Rights Reserved
+ *  Copyright 2001-2003 Ian Kent <raven@themaw.net>
  *
  * This file is part of the Linux kernel and is made available under
  * the terms of the GNU General Public License, version 2, or at your
@@ -27,7 +28,7 @@
 {
 	struct autofs_wait_queue *wq, *nwq;
 
-	DPRINTK(("autofs: entering catatonic mode\n"));
+	DPRINTK(("autofs4: entering catatonic mode\n"));
 
 	sbi->catatonic = 1;
 	wq = sbi->queues;
@@ -35,8 +36,10 @@
 	while ( wq ) {
 		nwq = wq->next;
 		wq->status = -ENOENT; /* Magic is gone - report failure */
-		kfree(wq->name);
-		wq->name = NULL;
+		if ( wq->name ) {
+			kfree(wq->name);
+			wq->name = NULL;
+		}
 		wake_up(&wq->queue);
 		wq = nwq;
 	}
@@ -90,8 +93,8 @@
 	union autofs_packet_union pkt;
 	size_t pktsz;
 
-	DPRINTK(("autofs_notify: wait id = 0x%08lx, name = %.*s, type=%d\n",
-		 wq->wait_queue_token, wq->len, wq->name, type));
+	DPRINTK(("autofs4_notify: wait id = 0x%08lx, name = %.*s, type=%d\n",
+		(unsigned long) wq->wait_queue_token, wq->len, wq->name, type));
 
 	memset(&pkt,0,sizeof pkt); /* For security reasons */
 
@@ -116,7 +119,7 @@
 		memcpy(ep->name, wq->name, wq->len);
 		ep->name[wq->len] = '\0';
 	} else {
-		printk("autofs_notify_daemon: bad type %d!\n", type);
+		printk("autofs4_notify_daemon: bad type %d!\n", type);
 		return;
 	}
 
@@ -124,62 +127,102 @@
 		autofs4_catatonic_mode(sbi);
 }
 
-int autofs4_wait(struct autofs_sb_info *sbi, struct qstr *name,
+static int autofs4_getpath(struct autofs_sb_info *sbi,
+			   struct dentry *dentry, char **name)
+{
+	struct dentry *root = sbi->sb->s_root;
+	struct dentry *tmp;
+	char *buf = *name;
+	char *p;
+	int len = 0;
+
+	spin_lock(&dcache_lock);
+	for (tmp = dentry ; tmp != root ; tmp = tmp->d_parent)
+		len += tmp->d_name.len + 1;
+
+	if (--len > NAME_MAX) {
+		spin_unlock(&dcache_lock);
+		return 0;
+	}
+
+	*(buf + len) = '\0';
+	p = buf + len - dentry->d_name.len;
+	strncpy(p, dentry->d_name.name, dentry->d_name.len);
+
+	for (tmp = dentry->d_parent; tmp != root ; tmp = tmp->d_parent) {
+		*(--p) = '/';
+		p -= tmp->d_name.len;
+		strncpy(p, tmp->d_name.name, tmp->d_name.len);
+	}
+/*	*name = buf; */
+	spin_unlock(&dcache_lock);
+
+	return len;
+}
+
+int autofs4_wait(struct autofs_sb_info *sbi, struct dentry *dentry,
 		enum autofs_notify notify)
 {
 	struct autofs_wait_queue *wq;
-	int status;
+	char *name;
+	int len, status;
 
 	/* In catatonic mode, we don't wait for nobody */
-	if ( sbi->catatonic )
+	if (sbi->catatonic)
 		return -ENOENT;
-	
-	/* We shouldn't be able to get here, but just in case */
-	if ( name->len > NAME_MAX )
+
+	name = kmalloc(NAME_MAX + 1, GFP_KERNEL);
+	if (!name)
+		return -ENOMEM;
+
+	len = autofs4_getpath(sbi, dentry, &name);
+	if (!len) {
+		kfree(name);
 		return -ENOENT;
+	}
 
 	for ( wq = sbi->queues ; wq ; wq = wq->next ) {
-		if ( wq->hash == name->hash &&
-		     wq->len == name->len &&
-		     wq->name && !memcmp(wq->name,name->name,name->len) )
+		if ( wq->hash == dentry->d_name.hash &&
+		     wq->len == len &&
+		     wq->name && !memcmp(wq->name, name, len) )
 			break;
 	}
 	
 	if ( !wq ) {
 		/* Create a new wait queue */
-		wq = kmalloc(sizeof(struct autofs_wait_queue),GFP_KERNEL);
-		if ( !wq )
-			return -ENOMEM;
-
-		wq->name = kmalloc(name->len,GFP_KERNEL);
-		if ( !wq->name ) {
-			kfree(wq);
+		wq = kmalloc(sizeof(struct autofs_wait_queue), GFP_KERNEL);
+		if ( !wq ) {
+			kfree(name);
 			return -ENOMEM;
 		}
+
 		wq->wait_queue_token = autofs4_next_wait_queue;
 		if (++autofs4_next_wait_queue == 0)
 			autofs4_next_wait_queue = 1;
 		init_waitqueue_head(&wq->queue);
-		wq->hash = name->hash;
-		wq->len = name->len;
+		wq->owner = current;
+		wq->hash = dentry->d_name.hash;
+		wq->name = name;
+		wq->len = len;
 		wq->status = -EINTR; /* Status return if interrupted */
-		memcpy(wq->name, name->name, name->len);
 		wq->next = sbi->queues;
+		wq->owner = current;
 		sbi->queues = wq;
 
-		DPRINTK(("autofs_wait: new wait id = 0x%08lx, name = %.*s, nfy=%d\n",
-			 wq->wait_queue_token, wq->len, wq->name, notify));
+		DPRINTK(("autofs4_wait: new wait id = 0x%08lx, name = %.*s, nfy=%d\n",
+			(unsigned long) wq->wait_queue_token, wq->len, wq->name, notify));
 		/* autofs4_notify_daemon() may block */
 		wq->wait_ctr = 2;
 		if (notify != NFY_NONE) {
 			autofs4_notify_daemon(sbi,wq, 
-					      notify == NFY_MOUNT ? autofs_ptype_missing :
-								    autofs_ptype_expire_multi);
+				notify == NFY_MOUNT ? 
+					autofs_ptype_missing :
+				       	autofs_ptype_expire_multi);
 		}
 	} else {
 		wq->wait_ctr++;
-		DPRINTK(("autofs_wait: existing wait id = 0x%08lx, name = %.*s, nfy=%d\n",
-			 wq->wait_queue_token, wq->len, wq->name, notify));
+		DPRINTK(("autofs4_wait: existing wait id = 0x%08lx, name = %.*s, nfy=%d\n",
+			(unsigned long) wq->wait_queue_token, wq->len, wq->name, notify));
 	}
 
 	/* wq->name is NULL if and only if the lock is already released */
@@ -204,7 +247,12 @@
 		recalc_sigpending(current);
 		spin_unlock_irqrestore(&current->sigmask_lock, irqflags);
 
-		interruptible_sleep_on(&wq->queue);
+		wait_event_interruptible(wq->queue, wq->name == NULL);
+
+		if (waitqueue_active(&wq->queue) && current != wq->owner) {
+			set_current_state(TASK_INTERRUPTIBLE);
+			schedule_timeout(HZ/10);
+		}
 
 		spin_lock_irqsave(&current->sigmask_lock, irqflags);
 		current->blocked = oldset;
@@ -243,7 +291,7 @@
 	if (--wq->wait_ctr == 0)	/* Is anyone still waiting for this guy? */
 		kfree(wq);
 	else
-		wake_up(&wq->queue);
+		wake_up_interruptible(&wq->queue);
 
 	return 0;
 }
diff -Nur linux-2.4.20.dist/include/linux/auto_fs4.h autofs4-2.4/include/linux/auto_fs4.h
--- linux-2.4.20.dist/include/linux/auto_fs4.h	2001-11-23 03:46:40.000000000 +0800
+++ autofs4-2.4/include/linux/auto_fs4.h	2003-11-09 19:33:53.000000000 +0800
@@ -23,6 +23,12 @@
 #define AUTOFS_MIN_PROTO_VERSION	3
 #define AUTOFS_MAX_PROTO_VERSION	4
 
+#define AUTOFS_PROTO_SUBVERSION		4
+
+/* Mask for expire behaviour */
+#define AUTOFS_EXP_IMMEDIATE            1
+#define AUTOFS_EXP_LEAVES               2
+
 /* New message type */
 #define autofs_ptype_expire_multi	2	/* Expire entry (umount request) */
 
@@ -41,7 +47,10 @@
 	struct autofs_packet_expire_multi expire_multi;
 };
 
-#define AUTOFS_IOC_EXPIRE_MULTI _IOW(0x93,0x66,int)
-
+#define AUTOFS_IOC_EXPIRE_MULTI		_IOW(0x93,0x66,int)
+#define AUTOFS_IOC_PROTOSUBVER		_IOR(0x93,0x67,int)
+#define AUTOFS_IOC_ASKREGHOST		_IOR(0x93,0x68,int)
+#define AUTOFS_IOC_TOGGLEREGHOST	_IOR(0x93,0x69,int)
+#define AUTOFS_IOC_ASKUMOUNT		_IOR(0x93,0x70,int)
 
 #endif /* _LINUX_AUTO_FS4_H */
diff -Nur linux-2.4.20.dist/include/linux/auto_fs.h autofs4-2.4/include/linux/auto_fs.h
--- linux-2.4.20.dist/include/linux/auto_fs.h	2003-06-13 22:51:38.000000000 +0800
+++ autofs4-2.4/include/linux/auto_fs.h	2003-11-09 19:33:53.000000000 +0800
@@ -45,7 +45,7 @@
  * If so, 32-bit user-space code should be backwards compatible.
  */
 
-#if !defined(__alpha__) && !defined(__ia64__)   
+#if defined(__sparc__) || defined(__mips__) || defined(__s390__) || defined(__powerpc__) || defined(__x86_64__)
 typedef unsigned int autofs_wqt_t;
 #else
 typedef unsigned long autofs_wqt_t;
