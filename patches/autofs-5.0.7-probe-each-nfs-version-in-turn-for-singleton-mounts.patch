Bottom: 4cf992487e79c44c2e5a28e2356679ac90dcd097
Top:    87328a64845ac5a419478eaf79ed92b1d05a2bca
Author: Ian Kent <raven@themaw.net>
Date:   2013-05-30 10:18:19 +0800

autofs-5.0.7 - probe each nfs version in turn for singleton mounts


---

diff --git a/include/replicated.h b/include/replicated.h
index ff0e7b9..728f131 100644
--- a/include/replicated.h
+++ b/include/replicated.h
@@ -68,6 +68,8 @@ struct host {
 };
 
 void seed_random(void);
+struct host *new_host(const char *, struct sockaddr *, size_t,
+		      unsigned int, unsigned int, unsigned int);
 void free_host_list(struct host **);
 int parse_location(unsigned, struct host **, const char *, unsigned int);
 int prune_host_list(unsigned, struct host **, unsigned int, int);
diff --git a/modules/mount_nfs.c b/modules/mount_nfs.c
index 5424d74..28ffcfc 100644
--- a/modules/mount_nfs.c
+++ b/modules/mount_nfs.c
@@ -180,9 +180,44 @@ int mount_mount(struct autofs_point *ap, const char *root, const char *name, int
 	 * We can't probe protocol rdma so leave it to mount.nfs(8)
 	 * and and suffer the delay if a server isn't available.
 	 */
-	if (!rdma)
+	if (rdma) {
+		singleton = 0;
+		goto dont_probe;
+	}
+
+	/*
+	 * If this is a singleton mount, and NFSv4 only hasn't been asked
+	 * for, and the default NFS protocol is set to v4 in the autofs
+	 * configuration only probe NFSv4 and let mount.nfs(8) do fallback
+	 * to NFSv3 (if it can). If the NFSv4 probe fails then probe as
+	 * normal.
+	 */
+	if (!this->next &&
+	    mount_default_proto == 4 &&
+	    vers & NFS_VERS_MASK != 0 &&
+	    vers & NFS4_VERS_MASK != 0) {
+		unsigned int v4_probe_ok = 0;
+		struct host *tmp = new_host(hosts->name,
+					    hosts->addr, hosts->addr_len,
+					    hosts->proximity,
+					    hosts->weight, hosts->options);
+		if (tmp) {
+			tmp->rr = hosts->rr;
+			prune_host_list(ap->logopt, &tmp,
+					NFS4_VERS_MASK|TCP_SUPPORTED, port);
+			/* If probe succeeds just try the mount with host in hosts */
+			if (tmp) {
+				v4_probe_ok = 1;
+				free_host_list(&tmp);
+			}
+		}
+		if (!v4_probe_ok)
+			prune_host_list(ap->logopt, &hosts, vers, port);
+	} else {
 		prune_host_list(ap->logopt, &hosts, vers, port);
+	}
 
+dont_probe:
 	if (!hosts) {
 		info(ap->logopt, MODPREFIX "no hosts available");
 		return 1;
diff --git a/modules/replicated.c b/modules/replicated.c
index 6dbdade..0a044b9 100644
--- a/modules/replicated.c
+++ b/modules/replicated.c
@@ -280,10 +280,10 @@ static unsigned int get_proximity(struct sockaddr *host_addr)
 	return PROXIMITY_OTHER;
 }
 
-static struct host *new_host(const char *name,
-			     struct sockaddr *addr, size_t addr_len,
-			     unsigned int proximity, unsigned int weight,
-			     unsigned int options)
+struct host *new_host(const char *name,
+		      struct sockaddr *addr, size_t addr_len,
+		      unsigned int proximity, unsigned int weight,
+		      unsigned int options)
 {
 	struct host *new;
 	struct sockaddr *tmp2;
