Bottom: b10774af614d756988a15191dee45e98d24552c1
Top:    67cb2178bf4e1485d153c9a1fff869539f59fd4a
Author: Ian Kent <raven@themaw.net>
Date:   2013-07-31 14:54:39 +0800

autofs-5.0.7 - teach dumpmaps to output simple key value pairs


---

diff --git a/daemon/automount.c b/daemon/automount.c
index 6849272..2008905 100644
--- a/daemon/automount.c
+++ b/daemon/automount.c
@@ -2125,20 +2125,31 @@ int main(int argc, char *argv[])
 			program);
 #endif
 
-	if (argc == 0)
-		master_list = master_new(NULL, timeout, ghost);
-	else
-		master_list = master_new(argv[0], timeout, ghost);
-
-	if (!master_list) {
-		printf("%s: can't create master map %s", program, argv[0]);
-		exit(1);
-	}
-
 	if (dumpmaps) {
 		struct master_mapent *entry;
 		struct list_head *head, *p;
 		struct mapent_cache *nc;
+		const char *type = NULL;
+		const char *name = NULL;
+		const char *master = NULL;
+
+		if (argc > 0) {
+			if (argc >= 2) {
+				type = argv[0];
+				name = argv[1];
+			}
+			if (argc == 3)
+				master = argv[2];
+		}
+
+		if (master)
+			master_list = master_new(NULL, timeout, ghost);
+		else
+			master_list = master_new(master, timeout, ghost);
+		if (!master_list) {
+			printf("%s: can't create master map", program);
+			exit(1);
+		}
 
 		open_log();
 
@@ -2153,7 +2164,10 @@ int main(int argc, char *argv[])
 		master_list->nc = nc;
 
 		lookup_nss_read_master(master_list, 0);
-		master_show_mounts(master_list);
+		if (type)
+			dump_map(master_list, type, name);
+		else
+			master_show_mounts(master_list);
 
 		head = &master_list->mounts;
 		p = head->next;
@@ -2168,6 +2182,16 @@ int main(int argc, char *argv[])
 		exit(0);
 	}
 
+	if (argc == 0)
+		master_list = master_new(NULL, timeout, ghost);
+	else
+		master_list = master_new(argv[0], timeout, ghost);
+
+	if (!master_list) {
+		printf("%s: can't create master map %s", program, argv[0]);
+		exit(1);
+	}
+
 	become_daemon(foreground, daemon_check);
 
 	if (pthread_attr_init(&th_attr)) {
diff --git a/lib/master.c b/lib/master.c
index c560496..3131a2e 100644
--- a/lib/master.c
+++ b/lib/master.c
@@ -1329,6 +1329,165 @@ static void print_map_info(struct map_source *source)
 	return;
 }
 
+static int match_map_name(struct map_source *source, const char *name)
+{
+	int argc = source->argc;
+	int i;
+
+	/*
+	 * This can't work for old style "multi" type sources since
+	 * there's no way to know from which map the cache entry came
+	 * from and duplicate entries are ignored at map read time.
+	 * All we can really do is list all the entries for the given
+	 * multi map if one of its map names matches.
+	 */
+	for (i = 0; i < argc; i++) {
+		if (i == 0 || !strcmp(source->argv[i], "--")) {
+			if (i != 0) {
+				i++;
+				if (i >= argc)
+					return 0;
+			}
+
+			if (source->argv[i] && *source->argv[i] != '-') {
+				if (!strcmp(source->argv[i], name))
+					return 1;
+			}
+		}
+	}
+
+	return;
+}
+
+static int compare_source_type(struct map_source *map, const char *type)
+{
+	int res = 0;
+
+	if (type) {
+		if (!map->type)
+			goto done;
+
+		if (strcmp(map->type, type))
+			goto done;
+	} else if (map->type)
+		goto done;
+
+	res = 1;
+done:
+	return res;
+}
+
+int dump_map(struct master *master, const char *type, const char *name)
+{
+	struct list_head *p, *head;
+
+	if (list_empty(&master->mounts)) {
+		printf("no master map entries found\n\n");
+		return 1;
+	}
+
+	head = &master->mounts;
+	p = head->next;
+	while (p != head) {
+		struct map_source *source;
+		struct master_mapent *this;
+		struct autofs_point *ap;
+		time_t now = time(NULL);
+		int i;
+
+		this = list_entry(p, struct master_mapent, list);
+		p = p->next;
+
+		ap = this->ap;
+
+		/*
+		 * Ensure we actually read indirect map entries so we can
+		 * list them. The map reads won't read any indirect map
+		 * entries (other than those in a file map) unless the
+		 * browse option is set.
+		 */
+		if (ap->type == LKP_INDIRECT)
+			ap->flags |= MOUNT_FLAG_GHOST;
+
+		/* Read the map content into the cache */
+		if (lookup_nss_read_map(ap, NULL, now))
+			lookup_prune_cache(ap, now);
+		else {
+			printf("failed to read map\n\n");
+			lookup_close_lookup(ap);
+			continue;
+		}
+
+		if (!this->maps) {
+			printf("no map sources found for %s\n", ap->path);
+			lookup_close_lookup(ap);
+			continue;
+		}
+
+		source = this->maps;
+		while (source) {
+			struct map_source *instance;
+			struct mapent *me;
+
+			instance = NULL;
+			if (source->type) {
+				if ((!strcmp(type, "file") &&
+				     strcmp(source->type, "files")) ||
+				     strcmp(source->type, type)) {
+					source = source->next;
+					continue;
+				}
+
+				if (!match_map_name(source, name)) {
+					source = source->next;
+					continue;
+				}
+
+				instance = source;
+			} else {
+				struct map_source *map;
+				int res;
+
+				map = source->instance;
+				while (map) {
+					res = compare_source_type(map, type);
+					if (res) {
+						if (!match_map_name(map, name)) {
+							map = map->next;
+							continue;
+						}
+						instance = map;
+						break;
+					}
+					map = map->next;
+				}
+			}
+
+			if (!instance) {
+				source = source->next;
+				lookup_close_lookup(ap);
+				continue;
+			}
+
+			me = cache_lookup_first(source->mc);
+			if (!me)
+				printf("no keys found in map\n");
+			else {
+				do {
+					if (me->source == instance)
+						printf("%s\t%s\n", me->key, me->mapent);
+				} while ((me = cache_lookup_next(source->mc, me)));
+			}
+
+			lookup_close_lookup(ap);
+			return 1;
+		}
+		lookup_close_lookup(ap);
+	}
+
+	return 0;
+}
+
 int master_show_mounts(struct master *master)
 {
 	struct list_head *p, *head;
