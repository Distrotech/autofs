Bottom: 706447a3776cafcfa8c1b32c3a2f2b89cbe7a1c7
Top:    5be316aefd55b80968fa5988fe99e63d9c8a20fa
Author: Ian Kent <raven@themaw.net>
Date:   2013-07-31 14:54:39 +0800

autofs-5.0.7 - teach dumpmaps to output simple key value pairs


---

diff --git a/daemon/automount.c b/daemon/automount.c
index 6849272..8bcc81e 100644
--- a/daemon/automount.c
+++ b/daemon/automount.c
@@ -2125,22 +2125,33 @@ int main(int argc, char *argv[])
 			program);
 #endif
 
-	if (argc == 0)
-		master_list = master_new(NULL, timeout, ghost);
-	else
-		master_list = master_new(argv[0], timeout, ghost);
-
-	if (!master_list) {
-		printf("%s: can't create master map %s", program, argv[0]);
-		exit(1);
-	}
-
 	if (dumpmaps) {
 		struct master_mapent *entry;
 		struct list_head *head, *p;
 		struct mapent_cache *nc;
+		const char *type = NULL;
+		const char *name = NULL;
+		const char *master = NULL;
+
+		if (argc > 0) {
+			if (argc >= 2) {
+				type = argv[0];
+				name = argv[1];
+			}
+			if (argc == 3)
+				master = argv[2];
+		}
+
+		if (master)
+			master_list = master_new(NULL, timeout, ghost);
+		else
+			master_list = master_new(master, timeout, ghost);
+		if (!master_list) {
+			printf("%s: can't create master map", program);
+			exit(1);
+		}
 
-		open_log();
+		log_to_stderr();
 
 		master_init_scan();
 
@@ -2153,7 +2164,10 @@ int main(int argc, char *argv[])
 		master_list->nc = nc;
 
 		lookup_nss_read_master(master_list, 0);
-		master_show_mounts(master_list);
+		if (type)
+			dump_map(master_list, type, name);
+		else
+			master_show_mounts(master_list);
 
 		head = &master_list->mounts;
 		p = head->next;
@@ -2168,6 +2182,16 @@ int main(int argc, char *argv[])
 		exit(0);
 	}
 
+	if (argc == 0)
+		master_list = master_new(NULL, timeout, ghost);
+	else
+		master_list = master_new(argv[0], timeout, ghost);
+
+	if (!master_list) {
+		printf("%s: can't create master map %s", program, argv[0]);
+		exit(1);
+	}
+
 	become_daemon(foreground, daemon_check);
 
 	if (pthread_attr_init(&th_attr)) {
diff --git a/include/master.h b/include/master.h
index 824707c..e77d5ba 100644
--- a/include/master.h
+++ b/include/master.h
@@ -112,6 +112,7 @@ int master_submount_list_empty(struct autofs_point *ap);
 int master_notify_submount(struct autofs_point *, const char *path, enum states);
 void master_notify_state_change(struct master *, int);
 int master_mount_mounts(struct master *, time_t, int);
+int dump_map(struct master *, const char *, const char *);
 int master_show_mounts(struct master *);
 extern inline unsigned int master_get_logopt(void);
 int master_list_empty(struct master *);
diff --git a/lib/master.c b/lib/master.c
index 734485e..bba959d 100644
--- a/lib/master.c
+++ b/lib/master.c
@@ -1329,6 +1329,173 @@ static void print_map_info(struct map_source *source)
 	return;
 }
 
+static int match_type(const char *source, const char *type)
+{
+	printf("match_type source %s type %s\n", source, type);
+	if (!strcmp(source, type)) {
+		printf("match\n");
+		return 1;
+	}
+	/* Source file and files are synonymous */
+	if (!strncmp(source, type, 4) && (strlen(source) <= 5)) {
+		printf("match\n");
+		return 1;
+	}
+	return 0;
+}
+
+static int match_name(struct map_source *source, const char *name)
+{
+	int argc = source->argc;
+	int ret = 0;
+	int i;
+
+	/*
+	 * This can't work for old style "multi" type sources since
+	 * there's no way to know from which map the cache entry came
+	 * from and duplicate entries are ignored at map read time.
+	 * All we can really do is list all the entries for the given
+	 * multi map if one of its map names matches.
+	 */
+	for (i = 0; i < argc; i++) {
+		if (i == 0 || !strcmp(source->argv[i], "--")) {
+			if (i != 0) {
+				i++;
+				if (i >= argc)
+					break;
+			}
+
+			if (source->argv[i] && *source->argv[i] != '-') {
+				char *map = strdup(source->argv[i]);
+				if (!map) {
+					printf("error: allocation failure: %s\n",
+						strerror(errno));
+					break;
+				}
+				if (!strcmp(basename(map), name)) {
+					ret = 1;
+					free(map);
+					break;
+				}
+				free(map);
+			}
+		}
+	}
+
+	return ret;
+}
+
+int dump_map(struct master *master, const char *type, const char *name)
+{
+	struct list_head *p, *head;
+
+	if (list_empty(&master->mounts)) {
+		printf("no master map entries found\n");
+		return 1;
+	}
+
+	head = &master->mounts;
+	p = head->next;
+	while (p != head) {
+		struct map_source *source;
+		struct master_mapent *this;
+		struct autofs_point *ap;
+		time_t now = time(NULL);
+
+		this = list_entry(p, struct master_mapent, list);
+		p = p->next;
+
+		ap = this->ap;
+
+		/*
+		 * Ensure we actually read indirect map entries so we can
+		 * list them. The map reads won't read any indirect map
+		 * entries (other than those in a file map) unless the
+		 * browse option is set.
+		 */
+		if (ap->type == LKP_INDIRECT)
+			ap->flags |= MOUNT_FLAG_GHOST;
+
+		/* Read the map content into the cache */
+		if (lookup_nss_read_map(ap, NULL, now))
+			lookup_prune_cache(ap, now);
+		else {
+			printf("failed to read map\n");
+			lookup_close_lookup(ap);
+			continue;
+		}
+
+		if (!this->maps) {
+			printf("no map sources found for %s\n", ap->path);
+			lookup_close_lookup(ap);
+			continue;
+		}
+
+		source = this->maps;
+		while (source) {
+			struct map_source *instance;
+			struct mapent *me;
+
+			instance = NULL;
+			if (source->type) {
+				if (!match_type(source->type, type)) {
+					source = source->next;
+					continue;
+				}
+
+				if (!match_name(source, name)) {
+					source = source->next;
+					continue;
+				}
+
+				instance = source;
+			} else {
+				struct map_source *map;
+
+				map = source->instance;
+				while (map) {
+					if (!match_type(map->type, type)) {
+						map = map->next;
+						continue;
+					}
+
+					if (!match_name(map, name)) {
+						map = map->next;
+						continue;
+					}
+
+					instance = map;
+					break;
+				}
+			}
+
+			printf("instance %p\n", instance);
+
+			if (!instance) {
+				source = source->next;
+				lookup_close_lookup(ap);
+				continue;
+			}
+
+			me = cache_lookup_first(source->mc);
+			if (!me)
+				printf("no keys found in map\n");
+			else {
+				do {
+					if (me->source == instance)
+						printf("%s\t%s\n", me->key, me->mapent);
+				} while ((me = cache_lookup_next(source->mc, me)));
+			}
+
+			lookup_close_lookup(ap);
+			return 1;
+		}
+		lookup_close_lookup(ap);
+	}
+
+	return 0;
+}
+
 int master_show_mounts(struct master *master)
 {
 	struct list_head *p, *head;
