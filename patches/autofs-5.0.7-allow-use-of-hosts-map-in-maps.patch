Bottom: af4afd3216b9addcb5809a68e568b3213b6c03a1
Top:    e670863f161c92e9816865d7b6831a9322a905b7
Author: Ian Kent <raven@themaw.net>
Date:   2013-08-19 09:57:34 +0800

autofs-5.0.7 - allow use of hosts map in maps

At the moment the internal hosts map can only be use as an entry in the
master map but there's no reason (I can think of so far) that it shouldn't
be possible to use it in map entries.


---

diff --git a/lib/parse_subs.c b/lib/parse_subs.c
index 2326838..cc1b4a4 100644
--- a/lib/parse_subs.c
+++ b/lib/parse_subs.c
@@ -35,6 +35,7 @@ static struct types map_type[] = {
 	{ "ldaps", 5 },
 	{ "hesiod", 6 },
 	{ "userdir", 7 },
+	{ "hosts", 5 },
 };
 static unsigned int map_type_count = sizeof(map_type)/sizeof(struct types);
 
diff --git a/modules/mount_autofs.c b/modules/mount_autofs.c
index 8c1e600..00a91e2 100644
--- a/modules/mount_autofs.c
+++ b/modules/mount_autofs.c
@@ -178,12 +178,14 @@ int mount_mount(struct autofs_point *ap, const char *root, const char *name,
 
 	argc = 1;
 
-	if (!(info = parse_map_type_info(what))) {
-		error(ap->logopt, MODPREFIX "failed to parse map info");
-		master_free_mapent(entry);
-		return 1;
+	if (what) {
+		if (!(info = parse_map_type_info(what))) {
+			error(ap->logopt, MODPREFIX "failed to parse map info");
+			master_free_mapent(entry);
+			return 1;
+		}
+		argv[0] = info->map;
 	}
-	argv[0] = info->map;
 
 	if (options) {
 		p = options;
@@ -192,7 +194,11 @@ int mount_mount(struct autofs_point *ap, const char *root, const char *name,
 				*p = '\0';
 				p++;
 			}
-			argv[argc++] = p;
+			if (strcmp(fstype, "autofs") &&
+			    strncmp(p, "hosts", 5))
+				info = parse_map_type_info("hosts:");
+			else
+				argv[argc++] = p;
 		} while ((p = strchr(p, ',')) != NULL);
 	}
 	argv[argc] = NULL;
diff --git a/modules/parse_sun.c b/modules/parse_sun.c
index c1fc528..c138b71 100644
--- a/modules/parse_sun.c
+++ b/modules/parse_sun.c
@@ -695,14 +695,18 @@ static int sun_mount(struct autofs_point *ap, const char *root,
 		rv = mount_nfs->mount_mount(ap, root, mountpoint, strlen(mountpoint),
 					    what, fstype, options, mount_nfs->context);
 	} else {
-		what = alloca(loclen + 1);
-		if (*loc == ':') {
-			loclen--;
-			memcpy(what, loc + 1, loclen);
-			what[loclen] = '\0';
-		} else {
-			memcpy(what, loc, loclen);
-			what[loclen] = '\0';
+		if (!loclen)
+			what = NULL;
+		else {
+			what = alloca(loclen + 1);
+			if (*loc == ':') {
+				loclen--;
+				memcpy(what, loc + 1, loclen);
+				what[loclen] = '\0';
+			} else {
+				memcpy(what, loc, loclen);
+				what[loclen] = '\0';
+			}
 		}
 
 		debug(ap->logopt, MODPREFIX
@@ -881,7 +885,8 @@ static int validate_location(unsigned int logopt, char *loc)
 		    !strncmp(ptr, "file:", 5) || !strncmp(ptr, "yp:", 3) ||
 		    !strncmp(ptr, "nis:", 4) || !strncmp(ptr, "nisplus:", 8) ||
 		    !strncmp(ptr, "ldap:", 5) || !strncmp(ptr, "ldaps:", 6) ||
-		    !strncmp(ptr, "sss:", 4) || !strncmp(ptr, "dir:", 4))
+		    !strncmp(ptr, "sss:", 4) || !strncmp(ptr, "dir:", 4) ||
+		    !strncmp(ptr, "hosts:", 4))
 			return 1;
 		error(logopt,
 		      "expected colon delimeter not found in location %s",
@@ -1433,8 +1438,11 @@ int parse_mount(struct autofs_point *ap, const char *name,
 			p += l;
 			p = skipspace(p);
 
+			error(LOGOPT_ANY, "options %s", options);
+
 			l = parse_mapent(p, options, &myoptions, &loc, ap->logopt);
-			if (!l) {
+			if (!(strstr(myoptions, "fstype=autofs") &&
+			     strstr(myoptions, "hosts")) || !l) {
 				cache_delete_offset_list(mc, name);
 				cache_multi_unlock(me);
 				cache_unlock(mc);
@@ -1592,13 +1600,20 @@ int parse_mount(struct autofs_point *ap, const char *name,
 			p = skipspace(p);
 		}
 
-		loclen = strlen(loc);
-		if (loclen == 0) {
-			free(loc);
-			free(options);
-			error(ap->logopt,
-			      MODPREFIX "entry %s is empty!", name);
-			return 1;
+		/* if it's not a hosts map loc must be non-null */
+		if ((strstr(options, "fstype=autofs") &&
+		      strstr(options, "hosts"))) {
+			loc = NULL;
+			loclen = 0;
+		} else {
+			loclen = strlen(loc);
+			if (loclen == 0) {
+				free(loc);
+				free(options);
+				error(ap->logopt,
+				      MODPREFIX "entry %s is empty!", name);
+				return 1;
+			}
 		}
 
 		debug(ap->logopt,
