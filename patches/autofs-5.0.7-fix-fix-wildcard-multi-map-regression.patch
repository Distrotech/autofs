Bottom: d76bf71c33fa4a7cebb9f197fddcdb0cb7d53340
Top:    e3c92b4bcdc18979c53c6b6e249b42e50607738d
Author: Ian Kent <raven@themaw.net>
Date:   2013-08-02 15:12:15 +0800

autofs-5.0.7 - fix fix wildcard multi map regression

A recent patch to fix a wildcard multi map mount regression has a
side effect of causing a deadlock at startup for direct mounts.

The patch required the map entry cache write lock to be taken so
the cache could be updated. But when starting the traversal of the
direct mount entries requires taking a read lock which caused the
deadlock.



---

diff --git a/modules/lookup_file.c b/modules/lookup_file.c
index 4b4ee89..4e4317f 100644
--- a/modules/lookup_file.c
+++ b/modules/lookup_file.c
@@ -1084,7 +1084,17 @@ int lookup_mount(struct autofs_point *ap, const char *name, int name_len, void *
 		}
 	}
 
-	cache_writelock(mc);
+	/*
+	 * We can't take the writelock for direct mounts. If we're
+	 * starting up or trying to re-connect to an existing direct
+	 * mount we could be iterating through the map entries with
+	 * the readlock held. But we don't need the write lock for
+	 * direct mounts so just take the readlock.
+	 */
+	if (ap->type == LKP_INDIRECT)
+		cache_writelock(mc);
+	else
+		cache_readlock(mc);
 do_cache_lookup:
 	me = cache_lookup(mc, key);
 	/*
@@ -1130,9 +1140,12 @@ do_cache_lookup:
 	ret = ctxt->parse->parse_mount(ap, key, key_len,
 				       mapent, ctxt->parse->context);
 	if (ret) {
-		cache_writelock(mc);
-		cache_update_negative(mc, source, key, ap->negative_timeout);
-		cache_unlock(mc);
+		/* Don't update negative cache when re-connecting */
+		if (!(ap->flags & MOUNT_FLAG_REMOUNT)) {
+			cache_writelock(mc);
+			cache_update_negative(mc, source, key, ap->negative_timeout);
+			cache_unlock(mc);
+		}
 		return NSS_STATUS_TRYAGAIN;
 	}
 
diff --git a/modules/lookup_ldap.c b/modules/lookup_ldap.c
index d05098f..fb8de9a 100644
--- a/modules/lookup_ldap.c
+++ b/modules/lookup_ldap.c
@@ -3016,7 +3016,17 @@ int lookup_mount(struct autofs_point *ap, const char *name, int name_len, void *
 			return status;
 	}
 
-	cache_writelock(mc);
+	/*
+	 * We can't take the writelock for direct mounts. If we're
+	 * starting up or trying to re-connect to an existing direct
+	 * mount we could be iterating through the map entries with
+	 * the readlock held. But we don't need the write lock for
+	 * direct mounts so just take the readlock.
+	 */
+	if (ap->type == LKP_INDIRECT)
+		cache_writelock(mc);
+	else
+		cache_readlock(mc);
 	me = cache_lookup(mc, key);
 	/* Stale mapent => check for entry in alternate source or wildcard */
 	if (me && !me->mapent) {
@@ -3053,9 +3063,12 @@ int lookup_mount(struct autofs_point *ap, const char *name, int name_len, void *
 	ret = ctxt->parse->parse_mount(ap, key, key_len,
 				       mapent, ctxt->parse->context);
 	if (ret) {
-		cache_writelock(mc);
-		cache_update_negative(mc, source, key, ap->negative_timeout);
-		cache_unlock(mc);
+		/* Don't update negative cache when re-connecting */
+		if (!(ap->flags & MOUNT_FLAG_REMOUNT)) {
+			cache_writelock(mc);
+			cache_update_negative(mc, source, key, ap->negative_timeout);
+			cache_unlock(mc);
+		}
 		return NSS_STATUS_TRYAGAIN;
 	}
 
diff --git a/modules/lookup_nisplus.c b/modules/lookup_nisplus.c
index ef942a7..fc31af3 100644
--- a/modules/lookup_nisplus.c
+++ b/modules/lookup_nisplus.c
@@ -561,7 +561,17 @@ int lookup_mount(struct autofs_point *ap, const char *name, int name_len, void *
 			return status;
 	}
 
-	cache_writelock(mc);
+	/*
+	 * We can't take the writelock for direct mounts. If we're
+	 * starting up or trying to re-connect to an existing direct
+	 * mount we could be iterating through the map entries with
+	 * the readlock held. But we don't need the write lock for
+	 * direct mounts so just take the readlock.
+	 */
+	if (ap->type == LKP_INDIRECT)
+		cache_writelock(mc);
+	else
+		cache_readlock(mc);
 	me = cache_lookup(mc, key);
 	/* Stale mapent => check for entry in alternate source or wildcard */
 	if (me && !me->mapent) {
@@ -603,15 +613,17 @@ int lookup_mount(struct autofs_point *ap, const char *name, int name_len, void *
 		time_t now = time(NULL);
 		int rv = CHE_OK;
 
-		cache_writelock(mc);
-		me = cache_lookup_distinct(mc, key);
-		if (!me)
-			rv = cache_update(mc, source, key, NULL, now);
-		if (rv != CHE_FAIL) {
+		/* Don't update negative cache when re-connecting */
+		if (!(ap->flags & MOUNT_FLAG_REMOUNT)) {
+			cache_writelock(mc);
 			me = cache_lookup_distinct(mc, key);
-			me->status = time(NULL) + ap->negative_timeout;
+			if (!me)
+				rv = cache_update(mc, source, key, NULL, now);
+			if (rv != CHE_FAIL) {
+				me = cache_lookup_distinct(mc, key);
+				me->status = time(NULL) + ap->negative_timeout;
+			cache_unlock(mc);
 		}
-		cache_unlock(mc);
 		free(mapent);
 		return NSS_STATUS_TRYAGAIN;
 	}
diff --git a/modules/lookup_sss.c b/modules/lookup_sss.c
index 1fe740b..7374bcb 100644
--- a/modules/lookup_sss.c
+++ b/modules/lookup_sss.c
@@ -635,7 +635,17 @@ int lookup_mount(struct autofs_point *ap, const char *name, int name_len, void *
 			return status;
 	}
 
-	cache_readlock(mc);
+	/*
+	 * We can't take the writelock for direct mounts. If we're
+	 * starting up or trying to re-connect to an existing direct
+	 * mount we could be iterating through the map entries with
+	 * the readlock held. But we don't need the write lock for
+	 * direct mounts so just take the readlock.
+	 */
+	if (ap->type == LKP_INDIRECT)
+		cache_writelock(mc);
+	else
+		cache_readlock(mc);
 	me = cache_lookup(mc, key);
 	/* Stale mapent => check for entry in alternate source or wildcard */
 	if (me && !me->mapent) {
@@ -672,9 +682,12 @@ int lookup_mount(struct autofs_point *ap, const char *name, int name_len, void *
 	ret = ctxt->parse->parse_mount(ap, key, key_len,
 				       mapent, ctxt->parse->context);
 	if (ret) {
-		cache_writelock(mc);
-		cache_update_negative(mc, source, key, ap->negative_timeout);
-		cache_unlock(mc);
+		/* Don't update negative cache when re-connecting */
+		if (!(ap->flags & MOUNT_FLAG_REMOUNT)) {
+			cache_writelock(mc);
+			cache_update_negative(mc, source, key, ap->negative_timeout);
+			cache_unlock(mc);
+		}
 		return NSS_STATUS_TRYAGAIN;
 	}
 
diff --git a/modules/lookup_yp.c b/modules/lookup_yp.c
index e99e3c0..783deff 100644
--- a/modules/lookup_yp.c
+++ b/modules/lookup_yp.c
@@ -662,7 +662,17 @@ int lookup_mount(struct autofs_point *ap, const char *name, int name_len, void *
 			return status;
 	}
 
-	cache_writelock(mc);
+	/*
+	 * We can't take the writelock for direct mounts. If we're
+	 * starting up or trying to re-connect to an existing direct
+	 * mount we could be iterating through the map entries with
+	 * the readlock held. But we don't need the write lock for
+	 * direct mounts so just take the readlock.
+	 */
+	if (ap->type == LKP_INDIRECT)
+		cache_writelock(mc);
+	else
+		cache_readlock(mc);
 	me = cache_lookup(mc, key);
 	/* Stale mapent => check for entry in alternate source or wildcard */
 	if (me && !me->mapent) {
@@ -698,9 +708,12 @@ int lookup_mount(struct autofs_point *ap, const char *name, int name_len, void *
 		ret = ctxt->parse->parse_mount(ap, key, key_len,
 					       mapent, ctxt->parse->context);
 		if (ret) {
-			cache_writelock(mc);
-			cache_update_negative(mc, source, key, ap->negative_timeout);
-			cache_unlock(mc);
+			/* Don't update negative cache when re-connecting */
+			if (!(ap->flags & MOUNT_FLAG_REMOUNT)) {
+				cache_writelock(mc);
+				cache_update_negative(mc, source, key, ap->negative_timeout);
+				cache_unlock(mc);
+			}
 			return NSS_STATUS_TRYAGAIN;
 		}
 	 }
