Bottom: 57539df5f4b3cf702a6f9700d9e1f00843d234c9
Top:    8df88534cd4cfb318f494e8100bdd8ede684b9d0
Author: Ian Kent <raven@themaw.net>
Date:   2013-08-02 15:12:15 +0800

autofs-5.0.7 - fix fix wildcard multi map regression


---

diff --git a/modules/lookup_file.c b/modules/lookup_file.c
index 4b4ee89..e9697e8 100644
--- a/modules/lookup_file.c
+++ b/modules/lookup_file.c
@@ -1084,7 +1084,19 @@ int lookup_mount(struct autofs_point *ap, const char *name, int name_len, void *
 		}
 	}
 
-	cache_writelock(mc);
+	error(LOGOPT_ANY, "take cache writelock");
+	/*
+	 * We can't take the writelock for direct mounts. If we're
+	 * starting up or trying to re-connect to an existing direct
+	 * mount we could be iterating through the map entries with
+	 * the readlock held. But we don't need the write lock for
+	 * direct mounts so just take the readlock.
+	 */
+	if (ap->type == LKP_INDIRECT)
+		cache_writelock(mc);
+	else
+		cache_readlock(mc);
+	error(LOGOPT_ANY, "got cache writelock");
 do_cache_lookup:
 	me = cache_lookup(mc, key);
 	/*
@@ -1130,9 +1142,12 @@ do_cache_lookup:
 	ret = ctxt->parse->parse_mount(ap, key, key_len,
 				       mapent, ctxt->parse->context);
 	if (ret) {
-		cache_writelock(mc);
-		cache_update_negative(mc, source, key, ap->negative_timeout);
-		cache_unlock(mc);
+		/* Don't update negative cache when re-connecting */
+		if (!(ap->flags & MOUNT_FLAG_REMOUNT)) {
+			cache_writelock(mc);
+			cache_update_negative(mc, source, key, ap->negative_timeout);
+			cache_unlock(mc);
+		}
 		return NSS_STATUS_TRYAGAIN;
 	}
 
diff --git a/modules/lookup_ldap.c b/modules/lookup_ldap.c
index d05098f..fb8de9a 100644
--- a/modules/lookup_ldap.c
+++ b/modules/lookup_ldap.c
@@ -3016,7 +3016,17 @@ int lookup_mount(struct autofs_point *ap, const char *name, int name_len, void *
 			return status;
 	}
 
-	cache_writelock(mc);
+	/*
+	 * We can't take the writelock for direct mounts. If we're
+	 * starting up or trying to re-connect to an existing direct
+	 * mount we could be iterating through the map entries with
+	 * the readlock held. But we don't need the write lock for
+	 * direct mounts so just take the readlock.
+	 */
+	if (ap->type == LKP_INDIRECT)
+		cache_writelock(mc);
+	else
+		cache_readlock(mc);
 	me = cache_lookup(mc, key);
 	/* Stale mapent => check for entry in alternate source or wildcard */
 	if (me && !me->mapent) {
@@ -3053,9 +3063,12 @@ int lookup_mount(struct autofs_point *ap, const char *name, int name_len, void *
 	ret = ctxt->parse->parse_mount(ap, key, key_len,
 				       mapent, ctxt->parse->context);
 	if (ret) {
-		cache_writelock(mc);
-		cache_update_negative(mc, source, key, ap->negative_timeout);
-		cache_unlock(mc);
+		/* Don't update negative cache when re-connecting */
+		if (!(ap->flags & MOUNT_FLAG_REMOUNT)) {
+			cache_writelock(mc);
+			cache_update_negative(mc, source, key, ap->negative_timeout);
+			cache_unlock(mc);
+		}
 		return NSS_STATUS_TRYAGAIN;
 	}
 
diff --git a/modules/lookup_nisplus.c b/modules/lookup_nisplus.c
index ef942a7..fc31af3 100644
--- a/modules/lookup_nisplus.c
+++ b/modules/lookup_nisplus.c
@@ -561,7 +561,17 @@ int lookup_mount(struct autofs_point *ap, const char *name, int name_len, void *
 			return status;
 	}
 
-	cache_writelock(mc);
+	/*
+	 * We can't take the writelock for direct mounts. If we're
+	 * starting up or trying to re-connect to an existing direct
+	 * mount we could be iterating through the map entries with
+	 * the readlock held. But we don't need the write lock for
+	 * direct mounts so just take the readlock.
+	 */
+	if (ap->type == LKP_INDIRECT)
+		cache_writelock(mc);
+	else
+		cache_readlock(mc);
 	me = cache_lookup(mc, key);
 	/* Stale mapent => check for entry in alternate source or wildcard */
 	if (me && !me->mapent) {
@@ -603,15 +613,17 @@ int lookup_mount(struct autofs_point *ap, const char *name, int name_len, void *
 		time_t now = time(NULL);
 		int rv = CHE_OK;
 
-		cache_writelock(mc);
-		me = cache_lookup_distinct(mc, key);
-		if (!me)
-			rv = cache_update(mc, source, key, NULL, now);
-		if (rv != CHE_FAIL) {
+		/* Don't update negative cache when re-connecting */
+		if (!(ap->flags & MOUNT_FLAG_REMOUNT)) {
+			cache_writelock(mc);
 			me = cache_lookup_distinct(mc, key);
-			me->status = time(NULL) + ap->negative_timeout;
+			if (!me)
+				rv = cache_update(mc, source, key, NULL, now);
+			if (rv != CHE_FAIL) {
+				me = cache_lookup_distinct(mc, key);
+				me->status = time(NULL) + ap->negative_timeout;
+			cache_unlock(mc);
 		}
-		cache_unlock(mc);
 		free(mapent);
 		return NSS_STATUS_TRYAGAIN;
 	}
diff --git a/modules/lookup_sss.c b/modules/lookup_sss.c
index 1fe740b..7374bcb 100644
--- a/modules/lookup_sss.c
+++ b/modules/lookup_sss.c
@@ -635,7 +635,17 @@ int lookup_mount(struct autofs_point *ap, const char *name, int name_len, void *
 			return status;
 	}
 
-	cache_readlock(mc);
+	/*
+	 * We can't take the writelock for direct mounts. If we're
+	 * starting up or trying to re-connect to an existing direct
+	 * mount we could be iterating through the map entries with
+	 * the readlock held. But we don't need the write lock for
+	 * direct mounts so just take the readlock.
+	 */
+	if (ap->type == LKP_INDIRECT)
+		cache_writelock(mc);
+	else
+		cache_readlock(mc);
 	me = cache_lookup(mc, key);
 	/* Stale mapent => check for entry in alternate source or wildcard */
 	if (me && !me->mapent) {
@@ -672,9 +682,12 @@ int lookup_mount(struct autofs_point *ap, const char *name, int name_len, void *
 	ret = ctxt->parse->parse_mount(ap, key, key_len,
 				       mapent, ctxt->parse->context);
 	if (ret) {
-		cache_writelock(mc);
-		cache_update_negative(mc, source, key, ap->negative_timeout);
-		cache_unlock(mc);
+		/* Don't update negative cache when re-connecting */
+		if (!(ap->flags & MOUNT_FLAG_REMOUNT)) {
+			cache_writelock(mc);
+			cache_update_negative(mc, source, key, ap->negative_timeout);
+			cache_unlock(mc);
+		}
 		return NSS_STATUS_TRYAGAIN;
 	}
 
diff --git a/modules/lookup_yp.c b/modules/lookup_yp.c
index e99e3c0..783deff 100644
--- a/modules/lookup_yp.c
+++ b/modules/lookup_yp.c
@@ -662,7 +662,17 @@ int lookup_mount(struct autofs_point *ap, const char *name, int name_len, void *
 			return status;
 	}
 
-	cache_writelock(mc);
+	/*
+	 * We can't take the writelock for direct mounts. If we're
+	 * starting up or trying to re-connect to an existing direct
+	 * mount we could be iterating through the map entries with
+	 * the readlock held. But we don't need the write lock for
+	 * direct mounts so just take the readlock.
+	 */
+	if (ap->type == LKP_INDIRECT)
+		cache_writelock(mc);
+	else
+		cache_readlock(mc);
 	me = cache_lookup(mc, key);
 	/* Stale mapent => check for entry in alternate source or wildcard */
 	if (me && !me->mapent) {
@@ -698,9 +708,12 @@ int lookup_mount(struct autofs_point *ap, const char *name, int name_len, void *
 		ret = ctxt->parse->parse_mount(ap, key, key_len,
 					       mapent, ctxt->parse->context);
 		if (ret) {
-			cache_writelock(mc);
-			cache_update_negative(mc, source, key, ap->negative_timeout);
-			cache_unlock(mc);
+			/* Don't update negative cache when re-connecting */
+			if (!(ap->flags & MOUNT_FLAG_REMOUNT)) {
+				cache_writelock(mc);
+				cache_update_negative(mc, source, key, ap->negative_timeout);
+				cache_unlock(mc);
+			}
 			return NSS_STATUS_TRYAGAIN;
 		}
 	 }
