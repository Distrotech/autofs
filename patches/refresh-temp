Bottom: 3d9abdef891638d104879efc8edab2ed2c4d6b73
Top:    f256cf4caf47041dcde69ed0cc72dc99def26723
Author: Ian Kent <raven@themaw.net>
Date:   2013-07-31 18:13:16 +0800

Refresh of debug.patch

---

diff --git a/daemon/automount.c b/daemon/automount.c
index fc339de..20db8af 100644
--- a/daemon/automount.c
+++ b/daemon/automount.c
@@ -2142,7 +2142,7 @@ int main(int argc, char *argv[])
 				master = argv[2];
 		}
 
-		error(LOGOPT_ANY, "type %s name %s master %s", type, name, master);
+		printf("type %s name %s master %s\n", type, name, master);
 
 		if (master)
 			master_list = master_new(NULL, timeout, ghost);
@@ -2153,7 +2153,7 @@ int main(int argc, char *argv[])
 			exit(1);
 		}
 
-		open_log();
+		log_to_stderr();
 
 		master_init_scan();
 
@@ -2167,7 +2167,7 @@ int main(int argc, char *argv[])
 
 		lookup_nss_read_master(master_list, 0);
 		if (type) {
-			error(LOGOPT_ANY, "call dump_map");
+			printf("call dump_map");
 			dump_map(master_list, type, name);
 		} else
 			master_show_mounts(master_list);
diff --git a/lib/master.c b/lib/master.c
index abc7306..adadec2 100644
--- a/lib/master.c
+++ b/lib/master.c
@@ -1399,6 +1399,8 @@ int dump_map(struct master *master, const char *type, const char *name)
 
 		ap = this->ap;
 
+		printf("ap->path %s\n", ap->path);
+
 		/*
 		 * Ensure we actually read indirect map entries so we can
 		 * list them. The map reads won't read any indirect map
@@ -1430,6 +1432,7 @@ int dump_map(struct master *master, const char *type, const char *name)
 
 			instance = NULL;
 			if (source->type) {
+				printf("source->type %s\n", source->type);
 				if ((!strcmp(type, "file") &&
 				     strcmp(source->type, "files")) ||
 				     strcmp(source->type, type)) {
@@ -1449,6 +1452,7 @@ int dump_map(struct master *master, const char *type, const char *name)
 
 				map = source->instance;
 				while (map) {
+					printf("map->type %s\n", map->type);
 					res = compare_source_type(map, type);
 					if (res) {
 						if (!match_map_name(map, name)) {
@@ -1462,6 +1466,8 @@ int dump_map(struct master *master, const char *type, const char *name)
 				}
 			}
 
+			printf("instance %p\n", instance);
+
 			if (!instance) {
 				source = source->next;
 				lookup_close_lookup(ap);
