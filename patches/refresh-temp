Bottom: 2d9ab2be9f950c8e89819e6bec7f2e4a4d19370d
Top:    07f4f6996873be363fc5fa97705c99e59c270ced
Author: Ian Kent <raven@themaw.net>
Date:   2013-08-02 18:56:45 +0800

Refresh of autofs-5.0.7-fix-fix-wildcard-multi-map-regression.patch

---

diff --git a/modules/lookup_file.c b/modules/lookup_file.c
index 4e4317f..f83d528 100644
--- a/modules/lookup_file.c
+++ b/modules/lookup_file.c
@@ -1088,13 +1088,14 @@ int lookup_mount(struct autofs_point *ap, const char *name, int name_len, void *
 	 * We can't take the writelock for direct mounts. If we're
 	 * starting up or trying to re-connect to an existing direct
 	 * mount we could be iterating through the map entries with
-	 * the readlock held. But we don't need the write lock for
-	 * direct mounts so just take the readlock.
+	 * the readlock held. But we don't need to update the cache
+	 * when we're starting up so just take the readlock in that
+	 * case.
 	 */
-	if (ap->type == LKP_INDIRECT)
-		cache_writelock(mc);
-	else
+	if (ap->flags & MOUNT_FLAG_REMOUNT) {
 		cache_readlock(mc);
+	else
+		cache_writelock(mc);
 do_cache_lookup:
 	me = cache_lookup(mc, key);
 	/*
@@ -1115,7 +1116,8 @@ do_cache_lookup:
 		 * Add wildcard match for later validation checks and
 		 * negative cache lookups.
 		 */
-		if (ap->type == LKP_INDIRECT && *me->key == '*') {
+		if (ap->type == LKP_INDIRECT && *me->key == '*' &&
+		   !(ap->flags & MOUNT_FLAG_REMOUNT)) {
 			ret = cache_update(mc, source, key, me->mapent, me->age);
 			if (!(ret & (CHE_OK | CHE_UPDATED)))
 				me = NULL;
diff --git a/modules/lookup_ldap.c b/modules/lookup_ldap.c
index fb8de9a..9f66b07 100644
--- a/modules/lookup_ldap.c
+++ b/modules/lookup_ldap.c
@@ -3020,13 +3020,14 @@ int lookup_mount(struct autofs_point *ap, const char *name, int name_len, void *
 	 * We can't take the writelock for direct mounts. If we're
 	 * starting up or trying to re-connect to an existing direct
 	 * mount we could be iterating through the map entries with
-	 * the readlock held. But we don't need the write lock for
-	 * direct mounts so just take the readlock.
+	 * the readlock held. But we don't need to update the cache
+	 * when we're starting up so just take the readlock in that
+	 * case.
 	 */
-	if (ap->type == LKP_INDIRECT)
-		cache_writelock(mc);
-	else
+	if (ap->flags & MOUNT_FLAG_REMOUNT) {
 		cache_readlock(mc);
+	else
+		cache_writelock(mc);
 	me = cache_lookup(mc, key);
 	/* Stale mapent => check for entry in alternate source or wildcard */
 	if (me && !me->mapent) {
@@ -3041,7 +3042,8 @@ int lookup_mount(struct autofs_point *ap, const char *name, int name_len, void *
 		 * Add wildcard match for later validation checks and
 		 * negative cache lookups.
 		 */
-		if (ap->type == LKP_INDIRECT && *me->key == '*') {
+		if (ap->type == LKP_INDIRECT && *me->key == '*' &&
+		   !(ap->flags & MOUNT_FLAG_REMOUNT)) {
 			ret = cache_update(mc, source, key, me->mapent, me->age);
 			if (!(ret & (CHE_OK | CHE_UPDATED)))
 				me = NULL;
diff --git a/modules/lookup_nisplus.c b/modules/lookup_nisplus.c
index 53e4a85..5e724b2 100644
--- a/modules/lookup_nisplus.c
+++ b/modules/lookup_nisplus.c
@@ -565,13 +565,14 @@ int lookup_mount(struct autofs_point *ap, const char *name, int name_len, void *
 	 * We can't take the writelock for direct mounts. If we're
 	 * starting up or trying to re-connect to an existing direct
 	 * mount we could be iterating through the map entries with
-	 * the readlock held. But we don't need the write lock for
-	 * direct mounts so just take the readlock.
+	 * the readlock held. But we don't need to update the cache
+	 * when we're starting up so just take the readlock in that
+	 * case.
 	 */
-	if (ap->type == LKP_INDIRECT)
-		cache_writelock(mc);
-	else
+	if (ap->flags & MOUNT_FLAG_REMOUNT) {
 		cache_readlock(mc);
+	else
+		cache_writelock(mc);
 	me = cache_lookup(mc, key);
 	/* Stale mapent => check for entry in alternate source or wildcard */
 	if (me && !me->mapent) {
@@ -586,7 +587,8 @@ int lookup_mount(struct autofs_point *ap, const char *name, int name_len, void *
 		 * Add wildcard match for later validation checks and
 		 * negative cache lookups.
 		 */
-		if (ap->type == LKP_INDIRECT && *me->key == '*') {
+		if (ap->type == LKP_INDIRECT && *me->key == '*' &&
+		   !(ap->flags & MOUNT_FLAG_REMOUNT)) {
 			ret = cache_update(mc, source, key, me->mapent, me->age);
 			if (!(ret & (CHE_OK | CHE_UPDATED)))
 				me = NULL;
diff --git a/modules/lookup_yp.c b/modules/lookup_yp.c
index 783deff..4c5c1ff 100644
--- a/modules/lookup_yp.c
+++ b/modules/lookup_yp.c
@@ -666,13 +666,14 @@ int lookup_mount(struct autofs_point *ap, const char *name, int name_len, void *
 	 * We can't take the writelock for direct mounts. If we're
 	 * starting up or trying to re-connect to an existing direct
 	 * mount we could be iterating through the map entries with
-	 * the readlock held. But we don't need the write lock for
-	 * direct mounts so just take the readlock.
+	 * the readlock held. But we don't need to update the cache
+	 * when we're starting up so just take the readlock in that
+	 * case.
 	 */
-	if (ap->type == LKP_INDIRECT)
-		cache_writelock(mc);
-	else
+	if (ap->flags & MOUNT_FLAG_REMOUNT) {
 		cache_readlock(mc);
+	else
+		cache_writelock(mc);
 	me = cache_lookup(mc, key);
 	/* Stale mapent => check for entry in alternate source or wildcard */
 	if (me && !me->mapent) {
@@ -687,7 +688,8 @@ int lookup_mount(struct autofs_point *ap, const char *name, int name_len, void *
 		 * Add wildcard match for later validation checks and
 		 * negative cache lookups.
 		 */
-		if (ap->type == LKP_INDIRECT && *me->key == '*') {
+		if (ap->type == LKP_INDIRECT && *me->key == '*' &&
+		   !(ap->flags & MOUNT_FLAG_REMOUNT)) {
 			ret = cache_update(mc, source, key, me->mapent, me->age);
 			if (!(ret & (CHE_OK | CHE_UPDATED)))
 				me = NULL;
