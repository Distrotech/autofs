Bottom: 07f4f6996873be363fc5fa97705c99e59c270ced
Top:    4ace8a5af825d66049eb065fa2a01e9714be081a
Author: Ian Kent <raven@themaw.net>
Date:   2013-08-02 19:11:37 +0800

Refresh of autofs-5.0.7-fix-fix-wildcard-multi-map-regression.patch

---

diff --git a/modules/lookup_file.c b/modules/lookup_file.c
index f83d528..6abf5df 100644
--- a/modules/lookup_file.c
+++ b/modules/lookup_file.c
@@ -1092,7 +1092,7 @@ int lookup_mount(struct autofs_point *ap, const char *name, int name_len, void *
 	 * when we're starting up so just take the readlock in that
 	 * case.
 	 */
-	if (ap->flags & MOUNT_FLAG_REMOUNT) {
+	if (ap->flags & MOUNT_FLAG_REMOUNT)
 		cache_readlock(mc);
 	else
 		cache_writelock(mc);
@@ -1113,8 +1113,8 @@ do_cache_lookup:
 	}
 	if (me && me->mapent) {
 		/*
-		 * Add wildcard match for later validation checks and
-		 * negative cache lookups.
+		 * If this is a lookup add wildcard match for later validation
+		 * checks and negative cache lookups.
 		 */
 		if (ap->type == LKP_INDIRECT && *me->key == '*' &&
 		   !(ap->flags & MOUNT_FLAG_REMOUNT)) {
@@ -1143,11 +1143,11 @@ do_cache_lookup:
 				       mapent, ctxt->parse->context);
 	if (ret) {
 		/* Don't update negative cache when re-connecting */
-		if (!(ap->flags & MOUNT_FLAG_REMOUNT)) {
-			cache_writelock(mc);
-			cache_update_negative(mc, source, key, ap->negative_timeout);
-			cache_unlock(mc);
-		}
+		if (ap->flags & MOUNT_FLAG_REMOUNT)
+			return NSS_STATUS_TRYAGAIN;
+		cache_writelock(mc);
+		cache_update_negative(mc, source, key, ap->negative_timeout);
+		cache_unlock(mc);
 		return NSS_STATUS_TRYAGAIN;
 	}
 
diff --git a/modules/lookup_ldap.c b/modules/lookup_ldap.c
index 9f66b07..7695fc2 100644
--- a/modules/lookup_ldap.c
+++ b/modules/lookup_ldap.c
@@ -3024,7 +3024,7 @@ int lookup_mount(struct autofs_point *ap, const char *name, int name_len, void *
 	 * when we're starting up so just take the readlock in that
 	 * case.
 	 */
-	if (ap->flags & MOUNT_FLAG_REMOUNT) {
+	if (ap->flags & MOUNT_FLAG_REMOUNT)
 		cache_readlock(mc);
 	else
 		cache_writelock(mc);
@@ -3039,8 +3039,8 @@ int lookup_mount(struct autofs_point *ap, const char *name, int name_len, void *
 	}
 	if (me && me->mapent) {
 		/*
-		 * Add wildcard match for later validation checks and
-		 * negative cache lookups.
+		 * If this is a lookup add wildcard match for later validation
+		 * checks and negative cache lookups.
 		 */
 		if (ap->type == LKP_INDIRECT && *me->key == '*' &&
 		   !(ap->flags & MOUNT_FLAG_REMOUNT)) {
@@ -3066,11 +3066,11 @@ int lookup_mount(struct autofs_point *ap, const char *name, int name_len, void *
 				       mapent, ctxt->parse->context);
 	if (ret) {
 		/* Don't update negative cache when re-connecting */
-		if (!(ap->flags & MOUNT_FLAG_REMOUNT)) {
-			cache_writelock(mc);
-			cache_update_negative(mc, source, key, ap->negative_timeout);
-			cache_unlock(mc);
-		}
+		if (ap->flags & MOUNT_FLAG_REMOUNT)
+			return NSS_STATUS_TRYAGAIN;
+		cache_writelock(mc);
+		cache_update_negative(mc, source, key, ap->negative_timeout);
+		cache_unlock(mc);
 		return NSS_STATUS_TRYAGAIN;
 	}
 
diff --git a/modules/lookup_nisplus.c b/modules/lookup_nisplus.c
index 5e724b2..4f31d26 100644
--- a/modules/lookup_nisplus.c
+++ b/modules/lookup_nisplus.c
@@ -569,7 +569,7 @@ int lookup_mount(struct autofs_point *ap, const char *name, int name_len, void *
 	 * when we're starting up so just take the readlock in that
 	 * case.
 	 */
-	if (ap->flags & MOUNT_FLAG_REMOUNT) {
+	if (ap->flags & MOUNT_FLAG_REMOUNT)
 		cache_readlock(mc);
 	else
 		cache_writelock(mc);
@@ -584,8 +584,8 @@ int lookup_mount(struct autofs_point *ap, const char *name, int name_len, void *
 	}
 	if (me && me->mapent) {
 		/*
-		 * Add wildcard match for later validation checks and
-		 * negative cache lookups.
+		 * If this is a lookup add wildcard match for later validation
+		 * checks and negative cache lookups.
 		 */
 		if (ap->type == LKP_INDIRECT && *me->key == '*' &&
 		   !(ap->flags & MOUNT_FLAG_REMOUNT)) {
@@ -615,19 +615,20 @@ int lookup_mount(struct autofs_point *ap, const char *name, int name_len, void *
 		time_t now = time(NULL);
 		int rv = CHE_OK;
 
+		free(mapent);
+
 		/* Don't update negative cache when re-connecting */
-		if (!(ap->flags & MOUNT_FLAG_REMOUNT)) {
-			cache_writelock(mc);
+		if (ap->flags & MOUNT_FLAG_REMOUNT)
+			return NSS_STATUS_TRYAGAIN;
+		cache_writelock(mc);
+		me = cache_lookup_distinct(mc, key);
+		if (!me)
+			rv = cache_update(mc, source, key, NULL, now);
+		if (rv != CHE_FAIL) {
 			me = cache_lookup_distinct(mc, key);
-			if (!me)
-				rv = cache_update(mc, source, key, NULL, now);
-			if (rv != CHE_FAIL) {
-				me = cache_lookup_distinct(mc, key);
-				me->status = time(NULL) + ap->negative_timeout;
-			}
-			cache_unlock(mc);
+			me->status = time(NULL) + ap->negative_timeout;
 		}
-		free(mapent);
+		cache_unlock(mc);
 		return NSS_STATUS_TRYAGAIN;
 	}
 	free(mapent);
diff --git a/modules/lookup_sss.c b/modules/lookup_sss.c
index 7374bcb..6bf9eb4 100644
--- a/modules/lookup_sss.c
+++ b/modules/lookup_sss.c
@@ -639,10 +639,11 @@ int lookup_mount(struct autofs_point *ap, const char *name, int name_len, void *
 	 * We can't take the writelock for direct mounts. If we're
 	 * starting up or trying to re-connect to an existing direct
 	 * mount we could be iterating through the map entries with
-	 * the readlock held. But we don't need the write lock for
-	 * direct mounts so just take the readlock.
+	 * the readlock held. But we don't need to update the cache
+	 * when we're starting up so just take the readlock in that
+	 * case.
 	 */
-	if (ap->type == LKP_INDIRECT)
+	if (ap->flags & MOUNT_FLAG_REMOUNT)
 		cache_writelock(mc);
 	else
 		cache_readlock(mc);
@@ -657,10 +658,10 @@ int lookup_mount(struct autofs_point *ap, const char *name, int name_len, void *
 	}
 	if (me && me->mapent) {
 		/*
-		 * Add wildcard match for later validation checks and
-		 * negative cache lookups.
+		 * If this is a lookup add wildcard match for later validation
 		 */
-		if (ap->type == LKP_INDIRECT && *me->key == '*') {
+		if (ap->type == LKP_INDIRECT && *me->key == '*' &&
+		   !(ap->flags & MOUNT_FLAG_REMOUNT)) {
 			ret = cache_update(mc, source, key, me->mapent, me->age);
 			if (!(ret & (CHE_OK | CHE_UPDATED)))
 				me = NULL;
@@ -683,11 +684,11 @@ int lookup_mount(struct autofs_point *ap, const char *name, int name_len, void *
 				       mapent, ctxt->parse->context);
 	if (ret) {
 		/* Don't update negative cache when re-connecting */
-		if (!(ap->flags & MOUNT_FLAG_REMOUNT)) {
-			cache_writelock(mc);
-			cache_update_negative(mc, source, key, ap->negative_timeout);
-			cache_unlock(mc);
-		}
+		if (ap->flags & MOUNT_FLAG_REMOUNT)
+			return NSS_STATUS_TRYAGAIN;
+		cache_writelock(mc);
+		cache_update_negative(mc, source, key, ap->negative_timeout);
+		cache_unlock(mc);
 		return NSS_STATUS_TRYAGAIN;
 	}
 
diff --git a/modules/lookup_yp.c b/modules/lookup_yp.c
index 4c5c1ff..4d1848e 100644
--- a/modules/lookup_yp.c
+++ b/modules/lookup_yp.c
@@ -670,7 +670,7 @@ int lookup_mount(struct autofs_point *ap, const char *name, int name_len, void *
 	 * when we're starting up so just take the readlock in that
 	 * case.
 	 */
-	if (ap->flags & MOUNT_FLAG_REMOUNT) {
+	if (ap->flags & MOUNT_FLAG_REMOUNT)
 		cache_readlock(mc);
 	else
 		cache_writelock(mc);
@@ -685,8 +685,8 @@ int lookup_mount(struct autofs_point *ap, const char *name, int name_len, void *
 	}
 	if (me && me->mapent) {
 		/*
-		 * Add wildcard match for later validation checks and
-		 * negative cache lookups.
+		 * If this is a lookup add wildcard match for later validation
+		 * checks and negative cache lookups.
 		 */
 		if (ap->type == LKP_INDIRECT && *me->key == '*' &&
 		   !(ap->flags & MOUNT_FLAG_REMOUNT)) {
@@ -711,11 +711,11 @@ int lookup_mount(struct autofs_point *ap, const char *name, int name_len, void *
 					       mapent, ctxt->parse->context);
 		if (ret) {
 			/* Don't update negative cache when re-connecting */
-			if (!(ap->flags & MOUNT_FLAG_REMOUNT)) {
-				cache_writelock(mc);
-				cache_update_negative(mc, source, key, ap->negative_timeout);
-				cache_unlock(mc);
-			}
+			if (ap->flags & MOUNT_FLAG_REMOUNT)
+				return NSS_STATUS_TRYAGAIN;
+			cache_writelock(mc);
+			cache_update_negative(mc, source, key, ap->negative_timeout);
+			cache_unlock(mc);
 			return NSS_STATUS_TRYAGAIN;
 		}
 	 }
