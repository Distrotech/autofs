Bottom: f8a509b32e9de060516b4b095307e363c25abb51
Top:    3cf789b5085dd31331d9d4ff218818a4d210478f
Author: Ian Kent <ikent@redhat.com>
Date:   2013-04-04 17:38:58 +0800

Refresh of autofs-5.0.7-syncronize-handle_mounts-shutdown.patch

---

diff --git a/daemon/automount.c b/daemon/automount.c
index 805128f..b2b1b68 100644
--- a/daemon/automount.c
+++ b/daemon/automount.c
@@ -1477,14 +1477,7 @@ static void handle_mounts_finish(void)
 	pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, &cancel_state);
 
 	finish_mutex_lock();
-	/* Poke signal handler if we haven't already done so */
-	if (!fc.busy)
-		pthread_kill(state_mach_thid, SIGTERM);
-	fc.busy++;
-	error(LOGOPT_ANY, "before signal fc.busy %d", fc.busy);
 	finish_cond_wait();
-	fc.busy--;
-	error(LOGOPT_ANY, "after wait fc.busy %d", fc.busy);
 	finish_mutex_unlock();
 
 	pthread_setcancelstate(cancel_state, NULL);
@@ -1540,15 +1533,26 @@ static void handle_mounts_cleanup(void *arg)
 
 	info(logopt, "shut down path %s", path);
 
-	master_mutex_unlock();
 
 	/*
 	 * If we are not a submount send a signal to the signal handler
 	 * so it can join with any completed handle_mounts() threads and
 	 * perform final cleanup.
 	 */
-	if (!submount)
+	if (!submount) {
+		/* Poke signal handler if we haven't already done so */
+		if (!fc.busy)
+			pthread_kill(state_mach_thid, SIGTERM);
+		error(LOGOPT_ANY, "before signal fc.busy %d", fc.busy);
+		fc.busy++;
+		master_mutex_unlock();
 		handle_mounts_finish();
+		master_mutex_lock();
+		fc.busy--;
+		error(LOGOPT_ANY, "after wait fc.busy %d", fc.busy);
+	}
+
+	master_mutex_unlock();
 
 	return;
 }
