Bottom: f150652ca82a5866f82c590caaa5312f4a3a62bf
Top:    8187fc685f7a3aa4d0eb5d2235d301456b916cd9
Author: Ian Kent <ikent@redhat.com>
Date:   2013-04-04 12:56:54 +0800

autofs-5.0.7 - syncronize handle_mounts() shutdown


---

diff --git a/daemon/automount.c b/daemon/automount.c
index 4c651cf..32862b8 100644
--- a/daemon/automount.c
+++ b/daemon/automount.c
@@ -85,8 +85,8 @@ pthread_attr_t th_attr_detached;
 struct master_readmap_cond mrc = {
 	PTHREAD_MUTEX_INITIALIZER, PTHREAD_COND_INITIALIZER, 0, NULL, 0, 0, 0, 0};
 
-struct startup_cond suc = {
-	PTHREAD_MUTEX_INITIALIZER, PTHREAD_COND_INITIALIZER, 0, 0};
+struct finish_cond fc = {
+	PTHREAD_MUTEX_INITIALIZER, PTHREAD_COND_INITIALIZER, 0};
 
 pthread_key_t key_thread_stdenv_vars;
 
@@ -1348,7 +1348,8 @@ static void *statemachine(void *arg)
 					return NULL;
 				}
 			} else {
-				if (master_done(master_list)) {
+				master_finish(master_list);
+				if (list_empty(&master_list->mounts)) {
 					master_mutex_unlock();
 					return NULL;
 				}
@@ -1443,6 +1444,49 @@ void handle_mounts_startup_cond_destroy(void *arg)
 	return;
 }
 
+void finish_mutex_lock(void)
+{
+	int status = pthread_mutex_lock(&fc.mutex);
+	if (status) {
+		logerr("failed to lock shutdown condition mutex!");
+		fatal(status);
+	}
+}
+
+void finish_mutex_unlock(void)
+{
+	int status = pthread_mutex_unlock(&fc.mutex);
+	if (status) {
+		logerr("failed to unlock shutdown condition mutex!");
+		fatal(status);
+	}
+}
+
+void finish_cond_wait(void)
+{
+	int status = pthread_cond_wait(&fc.cond, &fc.mutex);
+	if (status)
+		fatal(status);
+}
+
+static void handle_mounts_finish(void)
+{
+	int cancel_state;
+
+	pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, &cancel_state);
+
+	finish_mutex_lock();
+	fc.busy++;
+	error(LOGOPT_ANY, "before signal fc.busy %d", fc.busy);
+	/* Poke signal handler */
+	pthread_kill(state_mach_thid, SIGTERM);
+	finish_cond_wait();
+	error(LOGOPT_ANY, "after wait fc.busy %d", fc.busy);
+	finish_mutex_unlock();
+
+	pthread_setcancelstate(cancel_state, NULL);
+}
+
 static void handle_mounts_cleanup(void *arg)
 {
 	struct autofs_point *ap;
@@ -1493,15 +1537,15 @@ static void handle_mounts_cleanup(void *arg)
 
 	info(logopt, "shut down path %s", path);
 
+	master_mutex_unlock();
+
 	/*
 	 * If we are not a submount send a signal to the signal handler
 	 * so it can join with any completed handle_mounts() threads and
 	 * perform final cleanup.
 	 */
 	if (!submount)
-		pthread_kill(state_mach_thid, SIGTERM);
-
-	master_mutex_unlock();
+		handle_mounts_finish();
 
 	return;
 }
diff --git a/include/automount.h b/include/automount.h
index e72fa0d..565adad 100644
--- a/include/automount.h
+++ b/include/automount.h
@@ -353,6 +353,17 @@ struct startup_cond {
 int handle_mounts_startup_cond_init(struct startup_cond *suc);
 void handle_mounts_startup_cond_destroy(void *arg);
 
+struct finish_cond {
+	pthread_mutex_t mutex;
+	pthread_cond_t  cond;
+	unsigned int busy;
+};
+
+extern struct finish_cond fc;
+void finish_mutex_lock(void);
+void finish_mutex_unlock(void);
+void finish_cond_wait(void);
+
 struct master_readmap_cond {
 	pthread_mutex_t mutex;
 	pthread_cond_t  cond;
diff --git a/include/master.h b/include/master.h
index 824707c..25ce856 100644
--- a/include/master.h
+++ b/include/master.h
@@ -115,7 +115,7 @@ int master_mount_mounts(struct master *, time_t, int);
 int master_show_mounts(struct master *);
 extern inline unsigned int master_get_logopt(void);
 int master_list_empty(struct master *);
-int master_done(struct master *);
+void master_finish(struct master *);
 int master_kill(struct master *);
 
 #endif
diff --git a/lib/master.c b/lib/master.c
index a0e62f2..0a3725e 100644
--- a/lib/master.c
+++ b/lib/master.c
@@ -33,8 +33,8 @@ struct master *master_list = NULL;
 extern const char *global_options;
 extern long global_negative_timeout;
 
-/* Attribute to create a joinable thread */
-extern pthread_attr_t th_attr;
+/* Attribute to create a detached thread */
+extern pthread_attr_t th_attr_detached;
 
 extern struct startup_cond suc;
 
@@ -1057,7 +1057,7 @@ static int master_do_mount(struct master_mapent *entry)
 
 	debug(ap->logopt, "mounting %s", entry->path);
 
-	status = pthread_create(&thid, &th_attr, handle_mounts, &suc);
+	status = pthread_create(&thid, &th_attr_detached, handle_mounts, &suc);
 	if (status) {
 		crit(ap->logopt,
 		     "failed to create mount handler thread for %s",
@@ -1394,26 +1394,37 @@ int master_list_empty(struct master *master)
 	return res;
 }
 
-int master_done(struct master *master)
+void master_finish(struct master *master)
 {
 	struct list_head *head, *p;
 	struct master_mapent *entry;
-	int res = 0;
+	int status;
 
-	head = &master->completed;
-	p = head->next;
-	while (p != head) {
-		entry = list_entry(p, struct master_mapent, join);
-		p = p->next;
-		list_del(&entry->join);
-		pthread_join(entry->thid, NULL);
-		master_free_mapent_sources(entry, 1);
-		master_free_mapent(entry);
+	finish_mutex_lock();
+
+	error(LOGOPT_ANY, "before fc.busy %d", fc.busy);
+
+	while (fc.busy) {
+		head = &master->completed;
+		p = head->next;
+		while (p != head) {
+			entry = list_entry(p, struct master_mapent, join);
+			p = p->next;
+			list_del(&entry->join);
+			pthread_join(entry->thid, NULL);
+			master_free_mapent_sources(entry, 1);
+			master_free_mapent(entry);
+			fc.busy--;
+		}
 	}
-	if (list_empty(&master->mounts))
-		res = 1;
 
-	return res;
+	error(LOGOPT_ANY, "after fc.busy %d", fc.busy);
+
+	status = pthread_cond_broadcast(&fc);
+	if (status)
+		fatal(status);
+
+	finish_mutex_unlock();
 }
 
 inline unsigned int master_get_logopt(void)
