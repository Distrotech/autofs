Bottom: e9731220dc88a3d073f7178c9a08e98986b6cadd
Top:    4d9be6e67916049f264b6ad240bc8c800c5bfa1d
Author: Ian Kent <raven@themaw.net>
Date:   2013-07-30 10:03:58 +0800

autofs-5.0.7 - add dumpmap to file

The dumpmaps option doesn't allow maps to be output in <key, value>
pairs suitable for use as a file map.

This could be useful to save current maps as a backup for emergency
use.

If the dumpmaps option is given and there is an argument it is taken
as a comma seperated list of map names to be output. The given names
must match a existing map name and if so, and the map is available, it
is output to a file of that name unless such a file already exists. If
a file of the name of the map already exists then the map is ignored.


---

diff --git a/daemon/automount.c b/daemon/automount.c
index 1d0b64e..4aaeac3 100644
--- a/daemon/automount.c
+++ b/daemon/automount.c
@@ -1145,6 +1145,28 @@ static unsigned long getnumopt(char *str, char option)
 	return val;
 }
 
+static const char *getstropt(char *str, char option)
+{
+	char *names;
+	char *val;
+
+	if (!str || !*str)
+		return NULL;
+
+	names = str;
+	if (*names == '=')
+		names++;
+
+	val = strdup(names);
+	if (!val) {
+		fprintf(stderr,
+			"%s: option -%c, couldn't allocate storage for argument\n",
+			program, option);
+		exit(1);
+	}
+	return (const char *) val;
+}
+
 static void do_master_cleanup_unlock(void *arg)
 {
 	int status;
@@ -1911,10 +1933,11 @@ int main(int argc, char *argv[])
 	int logpri = -1;
 	unsigned ghost, logging, daemon_check;
 	unsigned dumpmaps, foreground, have_global_options;
+	const char *dump = NULL;
 	time_t timeout;
 	time_t age = time(NULL);
 	struct rlimit rlim;
-	const char *options = "+hp:t:vmdD:fVrO:l:n:CF";
+	const char *options = "+hp:t:vm:dD:fVrO:l:n:CF";
 	static const struct option long_options[] = {
 		{"help", 0, 0, 'h'},
 		{"pid-file", 1, 0, 'p'},
@@ -1925,7 +1948,7 @@ int main(int argc, char *argv[])
 		{"foreground", 0, 0, 'f'},
 		{"random-multimount-selection", 0, 0, 'r'},
 		{"negative-timeout", 1, 0, 'n'},
-		{"dumpmaps", 0, 0, 'm'},
+		{"dumpmaps", 2, 0, 'm'},
 		{"global-options", 1, 0, 'O'},
 		{"version", 0, 0, 'V'},
 		{"set-log-priority", 1, 0, 'l'},
@@ -2008,6 +2031,8 @@ int main(int argc, char *argv[])
 
 		case 'm':
 			dumpmaps = 1;
+			if (optstring)
+				dump = getstropt(optarg, opt);
 			break;
 
 		case 'O':
@@ -2151,7 +2176,9 @@ int main(int argc, char *argv[])
 		master_list->nc = nc;
 
 		lookup_nss_read_master(master_list, 0);
-		master_show_mounts(master_list);
+		master_show_mounts(master_list, dump);
+		if (dump)
+			free(dump);
 		exit(0);
 	}
 
diff --git a/include/automount.h b/include/automount.h
index 71787a5..15b1128 100644
--- a/include/automount.h
+++ b/include/automount.h
@@ -643,6 +643,26 @@ static inline FILE *open_fopen_r(const char *path)
 	return f;
 }
 
+static inline FILE *open_fopen_wx(const char *path)
+{
+	FILE *f;
+
+#if defined(O_CLOEXEC) && defined(SOCK_CLOEXEC)
+	if (cloexec_works != -1) {
+		f = fopen(path, "wxe");
+		if (f != NULL) {
+			check_cloexec(fileno(f));
+			return f;
+		}
+	}
+#endif
+	f = fopen(path, "wx");
+	if (f == NULL)
+		return NULL;
+	check_cloexec(fileno(f));
+	return f;
+}
+
 static inline FILE *open_setmntent_r(const char *table)
 {
 	FILE *tab;
diff --git a/include/master.h b/include/master.h
index 824707c..6166976 100644
--- a/include/master.h
+++ b/include/master.h
@@ -112,7 +112,7 @@ int master_submount_list_empty(struct autofs_point *ap);
 int master_notify_submount(struct autofs_point *, const char *path, enum states);
 void master_notify_state_change(struct master *, int);
 int master_mount_mounts(struct master *, time_t, int);
-int master_show_mounts(struct master *);
+int master_show_mounts(struct master *, const char *);
 extern inline unsigned int master_get_logopt(void);
 int master_list_empty(struct master *);
 int master_done(struct master *);
diff --git a/lib/master.c b/lib/master.c
index eca3523..75dbca0 100644
--- a/lib/master.c
+++ b/lib/master.c
@@ -1281,7 +1281,109 @@ static void list_source_instances(struct map_source *source, struct map_source *
 	return;
 }
 
-int master_show_mounts(struct master *master)
+static char *match_map_path(const char *match, const char *maps)
+{
+	char *names;
+	char *map_name;
+	char *this;
+	char *tok, *ptr, *tmp;
+	unsigned int found = 0;
+
+	tmp = strdup(match);
+	if (tmp)
+		names = strdup(maps);
+	if (!tmp || !names) {
+		if (tmp)
+			free(tmp);
+		/* Don't print "not found" message since we haven't looked */
+		found = 1;
+		goto fail;
+	}
+
+	/*if (strchr(tmp, '/'))
+		map_name = basename(tmp);
+	else */
+		map_name = tmp;
+
+	this = NULL;
+	ptr = NULL;
+	tok = strtok_r(names, ",", &ptr);
+	while (tok) {
+		if (strcmp(map_name, tok)) {
+			tok = strtok_r(NULL, ",", &ptr);
+			continue;
+		}
+		found = 1;
+		this = strdup(tok);
+		break;
+	}
+
+	free(tmp);
+	free(names);
+
+	if (!this)
+		goto fail;
+
+	return this;
+
+fail:
+	if (!found)
+		printf("map \"%s\" not found in \"%s\", not output\n",
+			match, maps);
+	else {
+		printf("failed to allocate working storage,\n");
+		printf("map %s ignored\n", match);
+	}
+
+	return NULL;
+}
+
+static void write_map(const char *map, struct mapent *first)
+{
+	struct mapent *me = first;
+	char *name, *out;
+	FILE *f;
+
+	/* map has no name (eg. hosts) */
+	if (!map) {
+		printf("  map has no name, not output\n");
+		return;
+	}
+
+	name = strdup(map);
+	if (!name) {
+		printf("  failed to allocate working storage, "
+		       "map %s not output\n", map);
+		return;
+	}
+
+	if (strchr(name, '/'))
+		out = basename(name);
+	else
+		out = name;
+
+	f = open_fopen_wx(out);
+	if (!f) {
+		printf("  failed to open output file %s: %s\n",
+			out, strerror(errno));
+		printf("  map file not created.\n");
+		free(name);
+		return;
+	}
+
+	do {
+		fprintf(f, "%s\t%s\n", me->key, me->mapent);
+	} while ((me = cache_lookup_next(first->mc, me)));
+
+	printf("  output map %s\n", out);
+
+	fclose(f);
+	free(name);
+
+	return;
+}
+
+int master_show_mounts(struct master *master, const char *maps)
 {
 	struct list_head *p, *head;
 
@@ -1311,6 +1413,7 @@ int master_show_mounts(struct master *master)
 		struct autofs_point *ap;
 		time_t now = time(NULL);
 		unsigned int count = 0;
+		char *map_path = NULL;
 		int i;
 
 		this = list_entry(p, struct master_mapent, list);
@@ -1320,6 +1423,14 @@ int master_show_mounts(struct master *master)
 
 		printf("\nMount point: %s\n", ap->path);
 
+		if (maps) {
+			map_path = match_map_path(ap->path, maps);
+			if (!map_path) {
+				printf("\n");
+				continue;
+			}
+		}
+
 		printf("\nsource(s):\n");
 
 		/*
@@ -1336,11 +1447,15 @@ int master_show_mounts(struct master *master)
 			lookup_prune_cache(ap, now);
 		else {
 			printf("  failed to read map\n\n");
+			if (map_path)
+				free(map_path);
 			continue;
 		}
 
 		if (!this->maps) {
 			printf("  no map sources found\n\n");
+			if (map_path)
+				free(map_path);
 			continue;
 		}
 
@@ -1373,16 +1488,24 @@ int master_show_mounts(struct master *master)
 				}
 			}
 
-			printf("\n");
-
 			me = cache_lookup_first(source->mc);
 			if (!me)
 				printf("  no keys found in map\n");
 			else {
+				if (map_path) {
+					write_map(source->argv[0], me);
+					goto next;
+				}
+
+				printf("\n");
+
 				do {
 					printf("  %s | %s\n", me->key, me->mapent);
 				} while ((me = cache_lookup_next(source->mc, me)));
 			}
+next:
+			if (map_path)
+				free(map_path);
 
 			count++;
