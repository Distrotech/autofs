Bottom: 792742960272f8ffa4fe3aef105f7dd780be12e8
Top:    74b33931ed28c46a5dd52a1deff5c181eee58725
Author: Ian Kent <raven@themaw.net>
Date:   2013-07-30 10:03:58 +0800

autofs-5.0.7 - add dumpmap to file

The dumpmaps option doesn't allow maps to be output in <key, value>
pairs suitable for use as a file map.

This could be useful to save current maps as a backup for emergency
use.

If the dumpmaps option is given and there is an argument it is taken
as a comma seperated list of map names to be output. The given names
must match a existing map name and if so, and the map is available, it
is output to a file of that name unless such a file already exists. If
a file of the name of the map already exists then the map is ignored.


---

diff --git a/daemon/automount.c b/daemon/automount.c
index 1d0b64e..1970edc 100644
--- a/daemon/automount.c
+++ b/daemon/automount.c
@@ -1145,6 +1145,28 @@ static unsigned long getnumopt(char *str, char option)
 	return val;
 }
 
+static const char *getstropt(char *str, char option)
+{
+	char *names;
+	char *val;
+
+	if (!str || !*str)
+		return NULL;
+
+	names = str;
+	if (*names == '=')
+		names++;
+
+	val = strdup(names);
+	if (!val) {
+		fprintf(stderr,
+			"%s: option -%c, couldn't allocate storage for argument\n",
+			program, option);
+		exit(1);
+	}
+	return (const char *) val;
+}
+
 static void do_master_cleanup_unlock(void *arg)
 {
 	int status;
@@ -1911,10 +1933,11 @@ int main(int argc, char *argv[])
 	int logpri = -1;
 	unsigned ghost, logging, daemon_check;
 	unsigned dumpmaps, foreground, have_global_options;
+	const char *dump = NULL;
 	time_t timeout;
 	time_t age = time(NULL);
 	struct rlimit rlim;
-	const char *options = "+hp:t:vmdD:fVrO:l:n:CF";
+	const char *options = "+hp:t:vm:dD:fVrO:l:n:CF";
 	static const struct option long_options[] = {
 		{"help", 0, 0, 'h'},
 		{"pid-file", 1, 0, 'p'},
@@ -1925,7 +1948,7 @@ int main(int argc, char *argv[])
 		{"foreground", 0, 0, 'f'},
 		{"random-multimount-selection", 0, 0, 'r'},
 		{"negative-timeout", 1, 0, 'n'},
-		{"dumpmaps", 0, 0, 'm'},
+		{"dumpmaps", 2, 0, 'm'},
 		{"global-options", 1, 0, 'O'},
 		{"version", 0, 0, 'V'},
 		{"set-log-priority", 1, 0, 'l'},
@@ -2008,6 +2031,8 @@ int main(int argc, char *argv[])
 
 		case 'm':
 			dumpmaps = 1;
+			if (optarg)
+				dump = getstropt(optarg, opt);
 			break;
 
 		case 'O':
@@ -2151,7 +2176,9 @@ int main(int argc, char *argv[])
 		master_list->nc = nc;
 
 		lookup_nss_read_master(master_list, 0);
-		master_show_mounts(master_list);
+		master_show_mounts(master_list, dump);
+		if (dump)
+			free((void *) dump);
 		exit(0);
 	}
 
diff --git a/include/automount.h b/include/automount.h
index 71787a5..15b1128 100644
--- a/include/automount.h
+++ b/include/automount.h
@@ -643,6 +643,26 @@ static inline FILE *open_fopen_r(const char *path)
 	return f;
 }
 
+static inline FILE *open_fopen_wx(const char *path)
+{
+	FILE *f;
+
+#if defined(O_CLOEXEC) && defined(SOCK_CLOEXEC)
+	if (cloexec_works != -1) {
+		f = fopen(path, "wxe");
+		if (f != NULL) {
+			check_cloexec(fileno(f));
+			return f;
+		}
+	}
+#endif
+	f = fopen(path, "wx");
+	if (f == NULL)
+		return NULL;
+	check_cloexec(fileno(f));
+	return f;
+}
+
 static inline FILE *open_setmntent_r(const char *table)
 {
 	FILE *tab;
diff --git a/include/master.h b/include/master.h
index 824707c..6166976 100644
--- a/include/master.h
+++ b/include/master.h
@@ -112,7 +112,7 @@ int master_submount_list_empty(struct autofs_point *ap);
 int master_notify_submount(struct autofs_point *, const char *path, enum states);
 void master_notify_state_change(struct master *, int);
 int master_mount_mounts(struct master *, time_t, int);
-int master_show_mounts(struct master *);
+int master_show_mounts(struct master *, const char *);
 extern inline unsigned int master_get_logopt(void);
 int master_list_empty(struct master *);
 int master_done(struct master *);
diff --git a/lib/master.c b/lib/master.c
index bbf4b4e..3f79f61 100644
--- a/lib/master.c
+++ b/lib/master.c
@@ -1329,7 +1329,121 @@ static void print_map_info(struct map_source *source)
 	return;
 }
 
-int master_show_mounts(struct master *master)
+static unsigned int match_map_path(const char *match, const char *maps)
+{
+	char *names;
+	char *tok, *ptr;
+	unsigned int found;
+
+	names = strdup(maps);
+	if (!names) {
+		printf("failed to allocate working storage,\n");
+		printf("map %s ignored\n", match);
+		return 0;
+	}
+
+	found = 0;
+	ptr = NULL;
+	tok = strtok_r(names, ",", &ptr);
+	while (tok) {
+		if (strcmp(match, tok)) {
+			tok = strtok_r(NULL, ",", &ptr);
+			continue;
+		}
+		found = 1;
+		break;
+	}
+
+	free(names);
+
+	if (!found) {
+		printf("map \"%s\" not found in \"%s\", not output\n",
+			match, maps);
+		return 0;
+	}
+
+	return 1;
+}
+
+static void write_map(const char *map, struct mapent *first)
+{
+	struct mapent *me = first;
+	char *name, *out;
+	FILE *f;
+
+	/* map has no name (eg. hosts) */
+	if (!map) {
+		printf("  map has no name, not output\n");
+		return;
+	}
+
+	name = strdup(map);
+	if (!name) {
+		printf("  failed to allocate working storage, "
+		       "map %s not output\n", map);
+		return;
+	}
+
+	if (strchr(name, '/'))
+		out = basename(name);
+	else
+		out = name;
+
+	f = open_fopen_wx(out);
+	if (!f) {
+		printf("  failed to open output file %s: %s\n",
+			out, strerror(errno));
+		printf("  map file not created.\n");
+		free(name);
+		return;
+	}
+
+	do {
+		fprintf(f, "%s\t%s\n", me->key, me->mapent);
+	} while ((me = cache_lookup_next(first->mc, me)));
+
+	printf("  output map %s\n", out);
+
+	fclose(f);
+	free(name);
+
+	return;
+}
+
+static void write_maps(struct map_source *source, struct mapent *first)
+{
+	int argc = source->argc;
+	int i;
+
+	for (i = 0; i < argc; i++) {
+		if (source->argv[i] && *source->argv[i] != '-') {
+			write_map(source->argv[i], first);
+			i++;
+		}
+
+		if (i >= argc)
+			return;
+
+		/* Look for next map */
+		if (!strcmp(source->argv[i], "--"))
+			continue;
+
+		/* Skip over arguments */
+		if (source->argv[i]) {
+			int j;
+
+			for (j = i; j < source->argc; j++) {
+				if (!strcmp(source->argv[j], "--"))
+					break;
+				i++;
+			}
+		}
+	}
+
+	return;
+}
+
+int master_show_mounts(struct master *master, const char *maps)
 {
 	struct list_head *p, *head;
 
@@ -1359,7 +1473,7 @@ int master_show_mounts(struct master *master)
 		struct autofs_point *ap;
 		time_t now = time(NULL);
 		unsigned int count = 0;
-		int i;
+		unsigned int matched = 0;
 
 		this = list_entry(p, struct master_mapent, list);
 		p = p->next;
@@ -1368,6 +1482,14 @@ int master_show_mounts(struct master *master)
 
 		printf("\nMount point: %s\n", ap->path);
 
+		if (maps) {
+			matched = match_map_path(ap->path, maps);
+			if (!matched) {
+				printf("\n");
+				continue;
+			}
+		}
+
 		printf("\nsource(s):\n");
 
 		/*
@@ -1411,22 +1533,28 @@ int master_show_mounts(struct master *master)
 					       " will be ignored at run time\n");
 			}
 
-			printf("\n");
-
 			me = cache_lookup_first(source->mc);
 			if (!me)
 				printf("  no keys found in map\n");
 			else {
+				if (matched) {
+					write_maps(source, me);
+					goto next;
+				}
+
+				printf("\n");
+
 				do {
 					printf("  %s | %s\n", me->key, me->mapent);
 				} while ((me = cache_lookup_next(source->mc, me)));
 			}
-
+next:
 			count++;
 
 			source = source->next;
 		}
 
+		lookup_close_lookup(ap);
 		printf("\n");
 	}
