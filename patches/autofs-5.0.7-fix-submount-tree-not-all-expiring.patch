Bottom: 77e6f9a64fe21d866c09b5e3cf02a3b39e104bc2
Top:    3d59313a044050cfa62d6b4447dfb35976e684a4
Author: Ian Kent <ikent@redhat.com>
Date:   2013-04-08 09:57:09 +0800

Due to the change in the expire-specific-submount-only patch, sub-mounts
within an indirect mount that follow a submount (in the check order) won't
be expired if that submount is busy.


---

diff --git a/lib/master.c b/lib/master.c
index a0e62f2..47c5ac9 100644
--- a/lib/master.c
+++ b/lib/master.c
@@ -907,7 +907,12 @@ int master_notify_submount(struct autofs_point *ap, const char *path, enum state
 
 		if (!master_submount_list_empty(this)) {
 			mounts_mutex_unlock(ap);
-			return master_notify_submount(this, path, state);
+			if (!master_notify_submount(this, path, state)) {
+				ret = 0;
+				mounts_mutex_lock(ap);
+				break;
+			}
+			mounts_mutex_lock(ap);
 		}
 
 		/* path not the same */
@@ -959,10 +964,7 @@ int master_notify_submount(struct autofs_point *ap, const char *path, enum state
 			st_mutex_lock();
 		}
 		st_mutex_unlock();
-		mounts_mutex_unlock(ap);
-
-		return ret;
-
+		break;
 	}
 
 	mounts_mutex_unlock(ap);
