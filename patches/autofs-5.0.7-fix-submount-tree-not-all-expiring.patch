Bottom: 77e6f9a64fe21d866c09b5e3cf02a3b39e104bc2
Top:    c1aa4d9f1823a167418a9c79d0441dc59580352e
Author: Ian Kent <ikent@redhat.com>
Date:   2013-04-08 09:57:09 +0800

Due to the change in the expire-specific-submount-only patch, sub-mounts
within an indirect mount that follow a submount (in the check order) won't
be expired if that submount is busy.


---

diff --git a/lib/master.c b/lib/master.c
index a0e62f2..440989e 100644
--- a/lib/master.c
+++ b/lib/master.c
@@ -907,7 +907,11 @@ int master_notify_submount(struct autofs_point *ap, const char *path, enum state
 
 		if (!master_submount_list_empty(this)) {
 			mounts_mutex_unlock(ap);
-			return master_notify_submount(this, path, state);
+			if (!master_notify_submount(this, path, state)) {
+				ret = 0;
+				break;
+			}
+			mounts_mutex_lock(ap);
 		}
 
 		/* path not the same */
@@ -921,6 +925,7 @@ int master_notify_submount(struct autofs_point *ap, const char *path, enum state
 		if (this->state == ST_SHUTDOWN) {
 			this = NULL;
 			st_mutex_unlock();
+			mounts_mutex_unlock(ap);
 			break;
 		}
 
@@ -960,13 +965,9 @@ int master_notify_submount(struct autofs_point *ap, const char *path, enum state
 		}
 		st_mutex_unlock();
 		mounts_mutex_unlock(ap);
-
-		return ret;
-
+		break;
 	}
 
-	mounts_mutex_unlock(ap);
-
 	return ret;
 }
