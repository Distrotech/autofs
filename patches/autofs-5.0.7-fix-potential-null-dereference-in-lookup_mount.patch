Bottom: 676a245422a93f850b73eb5f53bedcbf869be122
Top:    e99be4fe31a6aab090e5cff2e33258e1b9e3c0a4
Author: Ian Kent <raven@themaw.net>
Date:   2013-06-07 13:54:07 +0800

autofs-5.0.7 - fix potential null dereference in lookup_mount()

Updating a negative cache entry should always find an entry but the entry
lookup return isn't checked and probably should be.

Since this code is duplicated in several modules add it as a function to
the cache handling code.


---

diff --git a/include/automount.h b/include/automount.h
index 6ced842..71787a5 100644
--- a/include/automount.h
+++ b/include/automount.h
@@ -189,6 +189,7 @@ struct mapent *cache_lookup_offset(const char *prefix, const char *offset, int s
 struct mapent *cache_partial_match(struct mapent_cache *mc, const char *prefix);
 int cache_add(struct mapent_cache *mc, struct map_source *ms, const char *key, const char *mapent, time_t age);
 int cache_update_offset(struct mapent_cache *mc, const char *mkey, const char *key, const char *mapent, time_t age);
+void cache_update_negative(struct mapent_cache *mc, struct map_source *ms, const char *key, time_t timeout);
 int cache_set_parents(struct mapent *mm);
 int cache_update(struct mapent_cache *mc, struct map_source *ms, const char *key, const char *mapent, time_t age);
 int cache_delete(struct mapent_cache *mc, const char *key);
diff --git a/lib/cache.c b/lib/cache.c
index 1e05a99..1300130 100644
--- a/lib/cache.c
+++ b/lib/cache.c
@@ -680,6 +680,25 @@ done:
 	return ret; 
 }
 
+void cache_update_negative(struct mapent_cache *mc,
+			   struct map_source *ms, const char *key,
+			   time_t timeout)
+{
+	time_t now = time(NULL);
+	int rv = CHE_OK;
+
+	me = cache_lookup_distinct(mc, key);
+	if (!me)
+		rv = cache_update(mc, ms, key, NULL, now);
+	if (rv != CHE_FAIL) {
+		me = cache_lookup_distinct(mc, key);
+		if (me)
+			me->status = now + timeout;
+	}
+	return;
+}
+
+
 static struct mapent *get_parent(const char *key, struct list_head *head, struct list_head **pos)
 {
 	struct list_head *next;
diff --git a/modules/lookup_file.c b/modules/lookup_file.c
index 2836996..48f5789 100644
--- a/modules/lookup_file.c
+++ b/modules/lookup_file.c
@@ -1139,7 +1139,8 @@ do_cache_lookup:
 			rv = cache_update(mc, source, key, NULL, now);
 		if (rv != CHE_FAIL) {
 			me = cache_lookup_distinct(mc, key);
-			me->status = now + ap->negative_timeout;
+			if (me)
+				me->status = now + ap->negative_timeout;
 		}
 		cache_unlock(mc);
 		return NSS_STATUS_TRYAGAIN;
diff --git a/modules/lookup_ldap.c b/modules/lookup_ldap.c
index a59de92..92f955e 100644
--- a/modules/lookup_ldap.c
+++ b/modules/lookup_ldap.c
@@ -3021,7 +3021,8 @@ int lookup_mount(struct autofs_point *ap, const char *name, int name_len, void *
 			rv = cache_update(mc, source, key, NULL, now);
 		if (rv != CHE_FAIL) {
 			me = cache_lookup_distinct(mc, key);
-			me->status = now + ap->negative_timeout;
+			if (me)
+				me->status = now + ap->negative_timeout;
 		}
 		cache_unlock(mc);
 		return NSS_STATUS_TRYAGAIN;
diff --git a/modules/lookup_sss.c b/modules/lookup_sss.c
index 5c2ed0a..003ec1f 100644
--- a/modules/lookup_sss.c
+++ b/modules/lookup_sss.c
@@ -682,7 +682,8 @@ int lookup_mount(struct autofs_point *ap, const char *name, int name_len, void *
 			rv = cache_update(mc, source, key, NULL, now);
 		if (rv != CHE_FAIL) {
 			me = cache_lookup_distinct(mc, key);
-			me->status = now + ap->negative_timeout;
+			if (me)
+				me->status = now + ap->negative_timeout;
 		}
 		cache_unlock(mc);
 		return NSS_STATUS_TRYAGAIN;
diff --git a/modules/lookup_yp.c b/modules/lookup_yp.c
index a716e1f..f6095ad 100644
--- a/modules/lookup_yp.c
+++ b/modules/lookup_yp.c
@@ -707,7 +707,8 @@ int lookup_mount(struct autofs_point *ap, const char *name, int name_len, void *
 				rv = cache_update(mc, source, key, NULL, now);
 			if (rv != CHE_FAIL) {
 				me = cache_lookup_distinct(mc, key);
-				me->status = now + ap->negative_timeout;
+				if (me)
+					me->status = now + ap->negative_timeout;
 			}
 			cache_unlock(mc);
 		}
