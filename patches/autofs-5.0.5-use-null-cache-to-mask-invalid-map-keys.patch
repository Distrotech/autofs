Bottom: 6e36d62cf056a41ff3554e3413639e35cfa3475a
Top:    c4381deacdd1843ff0f0cd4a8fef9767a93bd599
Author: Ian Kent <raven@themaw.net>
Date:   2010-06-16 11:01:59 +0800

autofs-5.0.5 - use null cache to mask invalid map keys

We continually get requests to have some way of avoiding mount requests
for common invalid indirect map keys. The kernel has no choice but to
pass these to the daemon and there can be many such requests at times.

This patch extends the use of null map entry cache to allow paths
corresponding to these invalid keys to be added to the master map,
checked for and ignored when a mount request is received.


---

diff --git a/daemon/indirect.c b/daemon/indirect.c
index 09d784b..0c8834e 100644
--- a/daemon/indirect.c
+++ b/daemon/indirect.c
@@ -765,7 +765,6 @@ static void *do_mount_indirect(void *arg)
 	struct pending_args *args, mt;
 	struct autofs_point *ap;
 	char buf[PATH_MAX + 1];
-	struct stat st;
 	int len, status, state;
 
 	args = (struct pending_args *) arg;
@@ -789,21 +788,11 @@ static void *do_mount_indirect(void *arg)
 
 	pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, &state);
 
-	len = ncat_path(buf, sizeof(buf), ap->path, mt.name, mt.len);
+	len = cat_path(buf, sizeof(buf), ap->path, mt.name);
 	if (!len) {
-		crit(ap->logopt, "path to be mounted is to long");
+		crit(ap->logopt, "failed to make mount path");
 		ops->send_fail(ap->logopt,
-			       ap->ioctlfd, mt.wait_queue_token,
-			      -ENAMETOOLONG);
-		pthread_setcancelstate(state, NULL);
-		pthread_exit(NULL);
-	}
-
-	status = lstat(buf, &st);
-	if (status != -1 && !(S_ISDIR(st.st_mode) && st.st_dev == mt.dev)) {
-		error(ap->logopt,
-		      "indirect trigger not valid or already mounted %s", buf);
-		ops->send_ready(ap->logopt, ap->ioctlfd, mt.wait_queue_token);
+			       ap->ioctlfd, mt.wait_queue_token, -EINVAL);
 		pthread_setcancelstate(state, NULL);
 		pthread_exit(NULL);
 	}
@@ -836,11 +825,14 @@ static void *do_mount_indirect(void *arg)
 int handle_packet_missing_indirect(struct autofs_point *ap, autofs_packet_missing_indirect_t *pkt)
 {
 	struct ioctl_ops *ops = get_ioctl_ops();
+	struct mapent_cache *nc;
 	pthread_t thid;
+	char path[PATH_MAX + 1];
 	char buf[MAX_ERR_BUF];
 	struct pending_args *mt;
 	struct timespec wait;
 	struct timeval now;
+	struct stat st;
 	int status, state;
 
 	pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, &state);
@@ -859,6 +851,34 @@ int handle_packet_missing_indirect(struct autofs_point *ap, autofs_packet_missin
 		return 0;
 	}
 
+	len = ncat_path(path, sizeof(path), ap->path, pkt->name, pkt->len);
+	if (!len) {
+		crit(ap->logopt, "path to be mounted is to long");
+		ops->send_fail(ap->logopt,
+			       ap->ioctlfd, pkt->wait_queue_token,
+			      -ENAMETOOLONG);
+		pthread_setcancelstate(state, NULL);
+		return 1;
+	}
+
+	nc = ap->entry->master->nc;
+	ne = cache_lookup_distinct(nc, path);
+	if (ne) {
+		debug(ap->logopt, "nulled map key %s ignored", pkt->name);
+		ops->send_ready(ap->logopt, ap->ioctlfd, pkt->wait_queue_token);
+		pthread_setcancelstate(state, NULL);
+		return 0;
+	}
+
+	status = lstat(path, &st);
+	if (status != -1 && !(S_ISDIR(st.st_mode) && st.st_dev == pkt->dev)) {
+		error(ap->logopt,
+		      "indirect trigger not valid or already mounted %s", path);
+		ops->send_ready(ap->logopt, ap->ioctlfd, pkt->wait_queue_token);
+		pthread_setcancelstate(state, NULL);
+		return 0;
+	}
+
 	mt = malloc(sizeof(struct pending_args));
 	if (!mt) {
 		char *estr = strerror_r(errno, buf, MAX_ERR_BUF);
@@ -894,7 +914,7 @@ int handle_packet_missing_indirect(struct autofs_point *ap, autofs_packet_missin
 
 	status = pthread_create(&thid, &th_attr_detached, do_mount_indirect, mt);
 	if (status) {
-		error(ap->logopt, "expire thread create failed");
+		error(ap->logopt, "mount thread create failed");
 		ops->send_fail(ap->logopt,
 			       ap->ioctlfd, pkt->wait_queue_token, -status);
 		master_mutex_unlock();
diff --git a/daemon/state.c b/daemon/state.c
index 38617c3..f536fe9 100644
--- a/daemon/state.c
+++ b/daemon/state.c
@@ -358,20 +358,7 @@ static void do_readmap_mount(struct autofs_point *ap, struct mnt_list *mnts,
 	struct mapent *ne, *nested, *valid;
 
 	nc = ap->entry->master->nc;
-
 	ne = cache_lookup_distinct(nc, me->key);
-	if (!ne) {
-		nested = cache_partial_match(nc, me->key);
-		if (nested) {
-			error(ap->logopt,
-			      "removing invalid nested null entry %s",
-			      nested->key);
-			nested = cache_partial_match(nc, me->key);
-			if (nested)
-				cache_delete(nc, nested->key);
-		}
-	}
-
 	if (me->age < now || (ne && map->master_line > ne->age)) {
 		/*
 		 * The map instance may have changed, such as the map name or
diff --git a/lib/master.c b/lib/master.c
index 03d8f77..ea0841e 100644
--- a/lib/master.c
+++ b/lib/master.c
@@ -1160,15 +1160,6 @@ int master_mount_mounts(struct master *master, time_t age, int readall)
 			st_add_task(ap, ST_SHUTDOWN_PENDING);
 			continue;
 		}
-		nested = cache_partial_match(nc, this->path);
-		if (nested) {
-			error(ap->logopt,
-			     "removing invalid nested null entry %s",
-			     nested->key);
-			nested = cache_partial_match(nc, this->path);
-			if (nested)
-				cache_delete(nc, nested->key);
-		}
 		cache_unlock(nc);
 
 		st_mutex_lock();
