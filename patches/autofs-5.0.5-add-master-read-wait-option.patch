Bottom: 595d16b81a0c4e92b953604054118d2e7544a3e5
Top:    bfac059c5cbcdc6e7a505abf3d04fee5493ca914
Author: Ian Kent <raven@themaw.net>
Date:   2011-03-07 13:04:01 +0800

autofs-5.0.5 - add master read wait option

Add command line and configuration options to set the amount of time to
wait for the master map to become available at program start.


---

diff --git a/daemon/automount.c b/daemon/automount.c
index 293d8dc..fd12086 100644
--- a/daemon/automount.c
+++ b/daemon/automount.c
@@ -1943,11 +1943,11 @@ int main(int argc, char *argv[])
 	int logpri = -1;
 	unsigned ghost, logging, daemon_check;
 	unsigned dumpmaps, foreground, have_global_options;
-	unsigned master_read;
+	unsigned master_read, master_wait;
 	time_t timeout;
 	time_t age = time(NULL);
 	struct rlimit rlim;
-	const char *options = "+hp:t:vmdD:fVrO:l:n:CF";
+	const char *options = "+hp:t:vmdD:fVrO:l:n:CFM:";
 	static const struct option long_options[] = {
 		{"help", 0, 0, 'h'},
 		{"pid-file", 1, 0, 'p'},
@@ -1964,6 +1964,7 @@ int main(int argc, char *argv[])
 		{"set-log-priority", 1, 0, 'l'},
 		{"dont-check-daemon", 0, 0, 'C'},
 		{"force", 0, 0, 'F'},
+		{"master-wait", 1, 0, 'M'},
 		{0, 0, 0, 0}
 	};
 
@@ -1984,6 +1985,7 @@ int main(int argc, char *argv[])
 	nfs_mount_uses_string_options = check_nfs_mount_version(&vers, &check);
 
 	kpkt_len = get_kpkt_len();
+	master_wait = defaults_get_master_wait();
 	timeout = defaults_get_timeout();
 	ghost = defaults_get_browse_mode();
 	logging = defaults_get_logging();
@@ -2043,6 +2045,10 @@ int main(int argc, char *argv[])
 			dumpmaps = 1;
 			break;
 
+		case 'M':
+			master_wait = getnumopt(optarg, opt);
+			break;
+
 		case 'O':
 			if (!have_global_options) {
 				global_options = strdup(optarg);
@@ -2305,9 +2311,9 @@ int main(int argc, char *argv[])
 		 * a signal is received, in which case exit returning an
 		 * error.
 		 */
-		if (!do_master_read_master(master_list, age, 180)) {
-			logerr("%s: failed to read master map after 180 seconds!",
-			       program);
+		if (!do_master_read_master(master_list, age, master_wait)) {
+			logerr("%s: failed to read master map after %u seconds!",
+			       program, master_wait);
 			master_kill(master_list);
 			release_flag_file();
 			exit(3);
diff --git a/include/defaults.h b/include/defaults.h
index 871e14b..912c2d0 100644
--- a/include/defaults.h
+++ b/include/defaults.h
@@ -23,6 +23,7 @@
 #define DEFAULT_MASTER_MAP_NAME	"auto.master"
 
 #define DEFAULT_TIMEOUT			600
+#define DEFAULT_MASTER_WAIT		180
 #define DEFAULT_NEGATIVE_TIMEOUT	60
 #define DEFAULT_MOUNT_WAIT		-1
 #define DEFAULT_UMOUNT_WAIT		12
@@ -59,6 +60,7 @@ unsigned int defaults_read_config(unsigned int);
 const char *defaults_get_master_map(void);
 int defaults_master_set(void);
 unsigned int defaults_get_timeout(void);
+unsigned int defaults_get_master_wait(void);
 unsigned int defaults_get_negative_timeout(void);
 unsigned int defaults_get_browse_mode(void);
 unsigned int defaults_get_logging(void);
diff --git a/lib/defaults.c b/lib/defaults.c
index ae1162f..7eabb70 100644
--- a/lib/defaults.c
+++ b/lib/defaults.c
@@ -32,6 +32,7 @@
 #define ENV_NAME_MASTER_MAP		"MASTER_MAP_NAME"
 
 #define ENV_NAME_TIMEOUT		"TIMEOUT"
+#define ENV_NAME_MASTER_WAIT		"MASTER_WAIT"
 #define ENV_NAME_NEGATIVE_TIMEOUT	"NEGATIVE_TIMEOUT"
 #define ENV_NAME_BROWSE_MODE		"BROWSE_MODE"
 #define ENV_NAME_LOGGING		"LOGGING"
@@ -294,6 +295,181 @@ struct list_head *defaults_get_uris(void)
 	return list;
 }
 
+<<<<<<< current
+=======
+/*
+ * Read config env variables and check they have been set.
+ *
+ * This simple minded routine assumes the config file
+ * is valid bourne shell script without spaces around "="
+ * and that it has valid values.
+ */
+unsigned int defaults_read_config(unsigned int to_syslog)
+{
+	FILE *f;
+	char buf[MAX_LINE_LEN];
+	char *res;
+
+	f = open_fopen_r(DEFAULTS_CONFIG_FILE);
+	if (!f)
+		return 0;
+
+	while ((res = fgets(buf, MAX_LINE_LEN, f))) {
+		char *key, *value;
+
+		if (!parse_line(res, &key, &value))
+			continue;
+
+		if (check_set_config_value(key, ENV_NAME_MASTER_MAP, value, to_syslog) ||
+		    check_set_config_value(key, ENV_NAME_TIMEOUT, value, to_syslog) ||
+		    check_set_config_value(key, ENV_NAME_MASTER_WAIT, value, to_syslog) ||
+		    check_set_config_value(key, ENV_NAME_NEGATIVE_TIMEOUT, value, to_syslog) ||
+		    check_set_config_value(key, ENV_NAME_BROWSE_MODE, value, to_syslog) ||
+		    check_set_config_value(key, ENV_NAME_LOGGING, value, to_syslog) ||
+		    check_set_config_value(key, ENV_LDAP_TIMEOUT, value, to_syslog) ||
+		    check_set_config_value(key, ENV_LDAP_NETWORK_TIMEOUT, value, to_syslog) ||
+		    check_set_config_value(key, ENV_NAME_MAP_OBJ_CLASS, value, to_syslog) ||
+		    check_set_config_value(key, ENV_NAME_ENTRY_OBJ_CLASS, value, to_syslog) ||
+		    check_set_config_value(key, ENV_NAME_MAP_ATTR, value, to_syslog) ||
+		    check_set_config_value(key, ENV_NAME_ENTRY_ATTR, value, to_syslog) ||
+		    check_set_config_value(key, ENV_NAME_VALUE_ATTR, value, to_syslog) ||
+		    check_set_config_value(key, ENV_APPEND_OPTIONS, value, to_syslog) ||
+		    check_set_config_value(key, ENV_MOUNT_WAIT, value, to_syslog) ||
+		    check_set_config_value(key, ENV_UMOUNT_WAIT, value, to_syslog) ||
+		    check_set_config_value(key, ENV_AUTH_CONF_FILE, value, to_syslog) ||
+		    check_set_config_value(key, ENV_MAP_HASH_TABLE_SIZE, value, to_syslog) ||
+		    check_set_config_value(key, ENV_MOUNT_NFS_DEFAULT_PROTOCOL, value, to_syslog))
+			;
+	}
+
+	if (!feof(f) || ferror(f)) {
+		if (!to_syslog) {
+			fprintf(stderr,
+				"fgets returned error %d while reading %s\n",
+				ferror(f), DEFAULTS_CONFIG_FILE);
+		} else {
+			logmsg("fgets returned error %d while reading %s",
+			      ferror(f), DEFAULTS_CONFIG_FILE);
+		}
+		fclose(f);
+		return 0;
+	}
+
+	fclose(f);
+	return 1;
+}
+
+const char *defaults_get_master_map(void)
+{
+	char *master;
+
+	master = get_env_string(ENV_NAME_MASTER_MAP);
+	if (!master)
+		return strdup(default_master_map_name);
+
+	return (const char *) master;
+}
+
+int defaults_master_set(void)
+{
+	char *val = getenv(ENV_NAME_MASTER_MAP);
+	if (!val)
+		return 0;
+
+	return 1;
+}
+
+unsigned int defaults_get_timeout(void)
+{
+	long timeout;
+
+	timeout = get_env_number(ENV_NAME_TIMEOUT);
+	if (timeout < 0)
+		timeout = DEFAULT_TIMEOUT;
+
+	return (unsigned int) timeout;
+}
+
+unsigned int defaults_get_master_wait(void)
+{
+	long wait;
+
+	wait = get_env_number(ENV_NAME_MASTER_WAIT);
+	if (wait < 0)
+		wait = DEFAULT_MASTER_WAIT;
+
+	return (unsigned int) wait;
+}
+
+unsigned int defaults_get_negative_timeout(void)
+{
+	long n_timeout;
+
+	n_timeout = get_env_number(ENV_NAME_NEGATIVE_TIMEOUT);
+	if (n_timeout <= 0)
+		n_timeout = DEFAULT_NEGATIVE_TIMEOUT;
+
+	return (unsigned int) n_timeout;
+}
+
+unsigned int defaults_get_browse_mode(void)
+{
+	int res;
+
+	res = get_env_yesno(ENV_NAME_BROWSE_MODE);
+	if (res < 0)
+		res = DEFAULT_BROWSE_MODE;
+
+	return res;
+}
+
+unsigned int defaults_get_logging(void)
+{
+	char *res;
+	unsigned int logging = DEFAULT_LOGGING;
+
+	res = get_env_string(ENV_NAME_LOGGING);
+	if (!res)
+		return logging;
+
+	if (!strcasecmp(res, "none"))
+		logging = DEFAULT_LOGGING;
+	else {
+		if (!strcasecmp(res, "verbose"))
+			logging |= LOGOPT_VERBOSE;
+
+		if (!strcasecmp(res, "debug"))
+			logging |= LOGOPT_DEBUG;
+	}
+
+	free(res);
+
+	return logging;
+}
+
+unsigned int defaults_get_ldap_timeout(void)
+{
+	int res;
+
+	res = get_env_number(ENV_LDAP_TIMEOUT);
+	if (res < 0)
+		res = DEFAULT_LDAP_TIMEOUT;
+
+	return res;
+}
+
+unsigned int defaults_get_ldap_network_timeout(void)
+{
+	int res;
+
+	res = get_env_number(ENV_LDAP_NETWORK_TIMEOUT);
+	if (res < 0)
+		res = DEFAULT_LDAP_NETWORK_TIMEOUT;
+
+	return res;
+}
+
+>>>>>>> patched
 struct ldap_schema *defaults_get_default_schema(void)
 {
 	struct ldap_schema *schema;
diff --git a/man/auto.master.5.in b/man/auto.master.5.in
index c552e56..228af19 100644
--- a/man/auto.master.5.in
+++ b/man/auto.master.5.in
@@ -211,6 +211,10 @@ They are:
 .B TIMEOUT
 sets the default mount timeout (program default 600).
 .TP
+.B MASTER_WAIT
+sets the default maximum time to wait for the master map to become
+available if it cannot be read at program start (program default 180).
+.TP
 .B NEGATIVE_TIMEOUT
 Set the default timeout for caching failed key lookups (program default
 60). If the equivalent command line option is given it will override this
diff --git a/man/automount.8 b/man/automount.8
index dddebce..6df8994 100644
--- a/man/automount.8
+++ b/man/automount.8
@@ -34,6 +34,10 @@ Set the global minimum timeout, in seconds, until directories
 are unmounted. The default is 10 minutes. Setting the timeout
 to zero disables umounts completely.
 .TP
+.I "\-M, \-\-master-wait"
+Set the maximum time to wait for the master map to become available
+if it cannot be read at program start.
+.TP
 .I "\-n <seconds>, \-\-negative\-timeout <seconds>"
 Set the default timeout for caching failed key lookups. The default is 60 seconds.
 .TP
diff --git a/redhat/autofs.sysconfig.in b/redhat/autofs.sysconfig.in
index a8992c4..a856f25 100644
--- a/redhat/autofs.sysconfig.in
+++ b/redhat/autofs.sysconfig.in
@@ -9,6 +9,12 @@
 #
 TIMEOUT=300
 #
+# MASTER_WAIT - set the default maximum time to wait for the
+# 		master map to become available if it cannot
+# 		be read at program start (default 180).
+#
+#MASTER_WAIT=180
+#
 # NEGATIVE_TIMEOUT - set the default negative timeout for
 # 		     failed mount attempts (default 60).
 #
diff --git a/samples/autofs.conf.default.in b/samples/autofs.conf.default.in
index 1da89cf..f56344e 100644
--- a/samples/autofs.conf.default.in
+++ b/samples/autofs.conf.default.in
@@ -9,6 +9,12 @@
 #
 TIMEOUT=300
 #
+# MASTER_WAIT - set the default maximum time to wait for the
+# 		master map to become available if it cannot
+#		be read at program start (default 180).
+#
+#MASTER_WAIT=180
+#
 # NEGATIVE_TIMEOUT - set the default negative timeout for
 # 		     failed mount attempts (default 60).
 #
