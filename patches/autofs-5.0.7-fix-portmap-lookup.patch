Bottom: 8edbd1e235052bd9e6a4f20d0e3f6cc9f506acdf
Top:    29fdbfc2381ca6238bb2fcee970c7ec5725542a9
Author: Ian Kent <ikent@redhat.com>
Date:   2013-09-23 12:18:52 +0800

autofs-5.0.7 - fix portmap lookup

The autofs RPC library has fallen behind some.

When using IPv6 (rpbbind) version 3 or 4 is available whereas with IPv4
(portmap) verions 2 and 3 are available.

autofs uses the version defined by PMAPVERS in the portmap include files
whereas it should be using the RPCBVERS defines when using libtirpc.

In addition /etc/rpc should be used for program number lookup and
/etc/services should be used to lookup rpcbind/protmap port number.

This incompatibility only shows up when using IPv6 only.


---

diff --git a/CHANGELOG b/CHANGELOG
index 56d083a..aea47d3 100644
--- a/CHANGELOG
+++ b/CHANGELOG
@@ -78,6 +78,7 @@
 - fix bad mkdir permission on create.
 - setup program map env from macro table.
 - add short host name standard marco variable.
+- fix portmap lookup.
 
 25/07/2012 autofs-5.0.7
 =======================
diff --git a/aclocal.m4 b/aclocal.m4
index 637a775..7c7e405 100644
--- a/aclocal.m4
+++ b/aclocal.m4
@@ -428,6 +428,8 @@ if test "$af_have_libtirpc" = "yes"; then
     TIRPCLIB="-ltirpc"
 fi
 
+AC_CHECK_FUNCS([getrpcbyname])
+
 # restore flags
 CFLAGS="$af_check_libtirpc_save_cflags"
 LDFLAGS="$af_check_libtirpc_save_ldflags"
diff --git a/configure b/configure
index e6d5d4a..ee095df 100755
--- a/configure
+++ b/configure
@@ -3228,6 +3228,18 @@ $as_echo "#define TIRPC_WORKAROUND 1" >>confdefs.h
     TIRPCLIB="-ltirpc"
 fi
 
+for ac_func in getrpcbyname
+do :
+  ac_fn_c_check_func "$LINENO" "getrpcbyname" "ac_cv_func_getrpcbyname"
+if test "x$ac_cv_func_getrpcbyname" = xyes; then :
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_GETRPCBYNAME 1
+_ACEOF
+
+fi
+done
+
+
 # restore flags
 CFLAGS="$af_check_libtirpc_save_cflags"
 LDFLAGS="$af_check_libtirpc_save_ldflags"
diff --git a/include/config.h.in b/include/config.h.in
index 8a52080..bf94822 100644
--- a/include/config.h.in
+++ b/include/config.h.in
@@ -21,6 +21,9 @@
 /* define if you have E4FSCK */
 #undef HAVE_E4FSCK
 
+/* Define to 1 if you have the `getrpcbyname' function. */
+#undef HAVE_GETRPCBYNAME
+
 /* Define to 1 if you have the <inttypes.h> header file. */
 #undef HAVE_INTTYPES_H
 
diff --git a/include/rpc_subs.h b/include/rpc_subs.h
index b6d59f9..1d5357c 100644
--- a/include/rpc_subs.h
+++ b/include/rpc_subs.h
@@ -39,6 +39,8 @@
 #define RPC_CLOSE_ACTIVE	RPC_CLOSE_DEFAULT
 #define RPC_CLOSE_NOLINGER	0x0001
 
+extern const rpcvers_t rpcb_version;
+
 #define PMAP_TOUT_UDP	3
 #define PMAP_TOUT_TCP	5
 
diff --git a/lib/rpc_subs.c b/lib/rpc_subs.c
index f5742e8..1f35b01 100644
--- a/lib/rpc_subs.c
+++ b/lib/rpc_subs.c
@@ -43,6 +43,26 @@
                 } while (0)
 #endif
 
+#ifdef WITH_LIBTIRPC
+static const char *rpcb_pgmtbl[] = {
+	"rpcbind", "portmap", "portmapper", "sunrpc", NULL,
+};
+static const char *rpcb_netnametbl[] = {
+	"rpcbind", "portmapper", "sunrpc", NULL,
+};
+const rpcprog_t rpcb_prog = RPCBPROG;
+const rpcvers_t rpcb_version = RPCBVERS_4;
+#else
+static const char *rpcb_pgmtbl[] = {
+	NULL,
+};
+static const char *rpcb_netnametbl[] = {
+	NULL,
+};
+const rpcprog_t rpcb_prog = PMAPPROG;
+const rpcvers_t rpcb_version = PMAPVERS;
+#endif
+
 #include "mount.h"
 #include "rpc_subs.h"
 #include "automount.h"
@@ -315,6 +335,63 @@ static int rpc_do_create_client(struct sockaddr *addr, struct conn_info *info, i
 }
 #endif
 
+#ifdef HAVE_GETRPCBYNAME
+static pthread_mutex_t rpcb_mutex = PTHREAD_MUTEX_INITIALIZER;
+#endif
+
+static rpcprog_t rpc_getrpcbyname(const rpcprog_t program)
+{
+#ifdef HAVE_GETRPCBYNAME
+	struct rpcent *entry;
+	unsigned int i;
+
+	pthread_mutex_lock(&rpcb_mutex);
+	for (i = 0; rpcb_pgmtbl[i] != NULL; i++) {
+		entry = getrpcbyname(rpcb_pgmtbl[i]);
+		if (entry) {
+			pthread_mutex_unlock(&rpcb_mutex);
+			return (rpcprog_t)entry->r_number;
+		}
+	}
+	pthread_mutex_unlock(&rpcb_mutex);
+#endif
+	return program;
+}
+
+static unsigned short rpc_getservbyname(const char *service, const int protocol) 
+{
+	const struct addrinfo hints = {
+		.ai_family      = AF_INET,
+		.ai_protocol    = protocol,
+		.ai_flags       = AI_PASSIVE,
+	};
+	struct addrinfo *result;
+	const struct sockaddr_in *sin;
+	unsigned short port;
+
+	if (getaddrinfo(NULL, service, &hints, &result) != 0)
+		return 0;
+
+	sin = (const struct sockaddr_in *) result->ai_addr;
+	port = sin->sin_port;
+
+	freeaddrinfo(result);
+	return port;
+}
+
+static unsigned short rpc_getrpcbport(const int protocol)
+{
+	unsigned int i;
+
+	for (i = 0; rpcb_netnametbl[i] != NULL; i++) {
+		unsigned short port;
+		port = rpc_getservbyname(rpcb_netnametbl[i], protocol);
+		if (port)
+			return port;
+	}
+	return (unsigned short) PMAPPORT;
+}
+
 /*
  * Create an RPC client
  */
@@ -510,9 +587,9 @@ int rpc_portmap_getclient(struct conn_info *info,
 	info->host = host;
 	info->addr = addr;
 	info->addr_len = addr_len;
-	info->program = PMAPPROG;
-	info->port = PMAPPORT;
-	info->version = PMAPVERS;
+	info->program = rpc_getrpcbyname(rpcb_prog);
+	info->port = rpc_getrpcbport(proto);
+	info->version = rpcb_version;
 	info->proto = proto;
 	info->send_sz = RPCSMALLMSGSIZE;
 	info->recv_sz = RPCSMALLMSGSIZE;
@@ -555,9 +632,9 @@ int rpc_portmap_getport(struct conn_info *info,
 		pmap_info.host = info->host;
 		pmap_info.addr = info->addr;
 		pmap_info.addr_len = info->addr_len;
-		pmap_info.port = PMAPPORT;
-		pmap_info.program = PMAPPROG;
-		pmap_info.version = PMAPVERS;
+		pmap_info.port = rpc_getrpcbport(info->proto);
+		pmap_info.program = rpc_getrpcbyname(rpcb_prog);
+		pmap_info.version = rpcb_version;
 		pmap_info.proto = info->proto;
 		pmap_info.send_sz = RPCSMALLMSGSIZE;
 		pmap_info.recv_sz = RPCSMALLMSGSIZE;
